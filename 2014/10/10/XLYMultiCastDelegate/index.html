<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="kaizeiの日常"><title>XLYMultiCastDelegate 多播代理 | kaizeiとyimi</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">XLYMultiCastDelegate 多播代理</h1><a id="logo" href="/.">kaizeiとyimi</a><p class="description">kaizeiの日常</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">XLYMultiCastDelegate 多播代理</h1><div class="post-meta">Oct 10, 2014<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><!-- if page.toc--><!--   div(class='clear')--><!--     div(id='toc' class='toc-article')--><!--       div(class='toc-title')= __('contents')--><!--       != toc(page.content)--><div class="post-content"><p>通知中心NSNotificationCenter, 大家都知道怎么用. 需要add observer, 指定selector, 指定监听的通知(字符串), 在selector对应的方法中获取userInfo字典, 根据key获取value进行操作, 最后还得在某个时机remove observer. 虽然按照规范去编写代码不容易出错, 但是仍然有很多麻烦, selector的使用错误不容易在编译时检查, 通知和userInfo都是使用字符串, 需要大量定义和维护字符串常量. 这点有时候着实会让人很烦恼. 本文介绍一种利用<strong>消息转发</strong>和<strong>代理</strong>来做广播的想法.</p>
<p>记得做第一个项目时(一年多前...), 需要做聊天, 当时因为很多原因没有重新开发, 而是使用了之前项目的聊天模块代码, 结构十分混乱, 大量的使用了Notification并且很多地方的用法是错误的. 虽然开发得很不爽, 总之是硬扛下去了, 不堪回首. 期间积累了一些想法, 也写过一些demo验证了一些, 其中一个就是本文介绍的<code>MultiCastDelegate</code>. </p>
<p>我们遇到了一类问题, 当某个数据发生变化时, 可能有多个对象期望得到通知, 但是各自所处的线程或者Queue是不一样的. NSNotificationCenter除了在发送通知时的一些常量定义的问题外还有一个重要的特性: 通知的调用是在postNotification的调用线程中同步执行. 如果我们有主线程和后台的对象同时监听通知, NSNotificationCenter就无法满足需求了, 总是至少有一个observer不是在自己所属的线程或者Queue调起. 难道还要自己再次dispatch一下?</p>
<h2 id="xlymulticastdelegate">XLYMultiCastDelegate</h2>
<h3 id="-">使用简介</h3>
<p><strong><a href="https://github.com/kaizeiyimi/XLYMultiCastDelegate" target="_blank" rel="external">XLYMultiCastDelegate</a></strong>来拯救你. 它的中文名字叫多播代理? 其实是广播. 它的作用跟通知中心NSNotificationCenter很像, 要做的事情也是一对多的通知. 实现的思路严重依赖Objective-C的消息转发机制. 它不是完全的通知中心的代替实现, multiCastDelegate 其实需要使用一个protocol来初始化. 之后添加的observer或者说delegate必须要实现这个protocol, 否则将不能添加. 先看看基本使用, 再继续介绍.</p>
<pre><code class="objc hljs"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">SimpleProtocol</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span>
<span class="hljs-keyword">@optional</span>
- (<span class="hljs-keyword">void</span>)someOptionalMethod;
<span class="hljs-keyword">@end</span>

<span class="hljs-comment">//创建</span>
XLYMultiCastDelegate *multiDelegate = [[XLYMultiCastDelegate alloc] initWithConformingProtocol:<span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">SimpleProtocol</span>)];</span>
<span class="hljs-comment">//添加代理</span>
[multiDelegate addDelegate:<span class="hljs-keyword">self</span> dispatchQueue:dispatch_get_main_queue()];
<span class="hljs-comment">//需要有一个地方来保存multiCastDelegate实例</span>
<span class="hljs-keyword">self</span>.multiDelegate = (<span class="hljs-keyword">id</span>&lt;SimpleProtocol&gt;)multiDelegate;
<span class="hljs-comment">//可以检查是否实现了协议</span>
<span class="hljs-built_in">BOOL</span> result = [<span class="hljs-keyword">self</span>.multiDelegate conformsToProtocol:<span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">SimpleProtocol</span>)];</span></code></pre><p>调用其实很简单, 首先需要创建一个multiDelegate对象, SimpleProtocol真的很simple, 只有一个可选方法. 添加代理时可以指定dispatchQueue参数, 这个Queue将是代理方法被调起的Queue, 解决了通知中心不能往不同的线程或Queue发送通知的问题. 创建了multiDelegate对象当然需要找个地方存起来. 以后也可以随时添加或者移除delegate. 当然你可以检查multiDelegate是否实现了协议, 结果是YES.</p>
<h3 id="-">原理说明</h3>
<p>下面详细说明一下实现的细节和需要注意的问题, 会涉及到一些runtime的知识, 这里不做详细的介绍, 需要了解的请参阅<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">苹果的文档</a>. 这里先仅对OC环境进行说明, swift的后面单独说明.</p>
<ul>
<li>协议检查</li>
</ul>
<p>协议是一个<code>Protocol *</code>类型. 代码中可以这样声明变量和获取协议:</p>
<pre><code class="objc hljs"><span class="hljs-comment">//声明为property</span>
<span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) Protocol *protocol;

<span class="hljs-comment">//获取</span>
<span class="hljs-built_in">NSString</span> *protocolName = <span class="hljs-string">@"SimpleProtocol"</span>;
Protocol *protocol = objc_getProtocol(protocolName.UTF8String);

<span class="hljs-comment">//或者</span>
Protocol *protocol = <span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">SimpleProtocol</span>);</span></code></pre><p>我们需要记录下当前多播代理所支持的协议, 协议在runtime环境里面应该是单例的形式存在的. 在添加新的delegate到多播代理中时进行的检查很简单 <code>[delegate conformsToProtocol:self.protocol]</code>, 如果通过则允许添加. 内部会创建一个delegateNode对象来weak持有添加的delegate, 并记录对应的delegateQueue. 还有一些添加删除的管理delegate的方法就不多说, 都是些简单逻辑.</p>
<ul>
<li><p>runtime支持</p>
</li>
<li><p>重写 <code>-[NSObject conformsToProtocol:]</code>方法, 判定是否实现了某个协议. </p>
</li>
<li><p>重写 <code>-[NSObject respondsToSelector:]</code>方法, 遍历现有的代理, 只要任何一个能够响应则认为能够响应.</p>
</li>
<li><p>重写 <code>-[NSObject methodSignatureForSelector:]</code>方法, 详细文档说明参考apple的runtime文档, 我们这里的场景是multiDelegate自己不能响应方法调用, 因此需要做调用转发, 这个时候该方法会被调用来给<code>NSInvocation</code>对象设置方法签名. 是为自己不能响应的方法寻找方法签名, 仍然遍历现有的代理, 找到一个正确地签名即可. 签名记录了这个方法的返回值类型, receiver的类型, 以及参数个数等信息. 如果没有delegate能够提供签名, 则默认提供doNothing的方法签名, 正如其名, 啥也不做, 只是为了不崩溃. 这个行为也可以理解为消息没有接受者则丢弃.</p>
</li>
<li><p>重写 <code>-[NSObject forwardInvocation:]</code>方法, 这里就是最重要的地方. 当一个对象不能相应一个selector调用时, 满足一些条件的情况下最终会走到这里, 条件如何达成请参阅<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">苹果文档</a>, 当然我们这里是达成了, 现在我们得到了一个invocation对象, 它包含了方法签名, 参数等信息, 是对一个对象进行方法调用的一个封装. NSInvocation对象有一个方法<code>-[NSInvocation invokeWithTarget:]</code>, 其作用就是将target作为方法调用的receiver进行调用, 参数不变. 所以我们将遍历所有的delegate, 并在它们的delegateQueue里面进行调用, 这样就完成了消息调用的转发.</p>
</li>
</ul>
<h3 id="-">需要注意的问题</h3>
<ol>
<li>创建XLYMultiCastDelegate实例, 添加移除delegate等管理操作都是线程不安全的, 需要使用者维护.</li>
<li>本质上是想用代理方法调用来完成通知, 因此应该将其应用于没有返回值的代理方法. 如果一定要发送带返回值的方法调用, 内部逻辑会在发送调用的线程中同步寻找第一个能够响应此方法的delegate并调用. 这里不能使用dispatch_async, 必须同步调用, 否则调用者会立即得到nil的返回值.</li>
<li>遍历delegate并进行方法调用的for循环使用了信号量来进行同步. Invocation不支持copy, 并且有一个问题: 如果在不同的线程同时对同一个invocation对象调用<code>-[NSInvocation invokeWithTarget:]</code>, 可能会出错, 这个错误不是崩溃, 而是target的处理错误. 比如对A,B同时进行调用, invoke调用时应该会记录当前的receiver(根据结果现象推断的), 中间还会经过一些步骤才会真正发起调用, A先被记录, 在发起调用前, B又被记录, 则两次调用的结果会是调用了两次B. 因此需要同步一下, 保证invocation对象的串行使用.</li>
</ol>
<h3 id="swift-">swift支持</h3>
<p>很不巧, 苹果发布的新的编程语言swift对runtime, KVO, KVC的支持很不友好. swift加入了模块的概念来解决OC多年的全局符号表的痛, 还有可选值什么的一些新概念. 其他的特性就是5仁月饼. 如果能够习惯OC中的block, 闭包, 那么swift里面的东西就没啥问题了, 都是些语言细节, 底层依然是runtime来支撑, 可以和OC混合编译. 细节请参阅<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html" target="_blank" rel="external">swift</a>.</p>
<p>本来想直接用swift重新实现的, 结果被直接拒绝了. swift中不允许使用NSInvocation对象, 只能混编了. 获取协议对象时需要注意是否是swift中定义的协议:</p>
<pre><code class="null hljs"><span class="hljs-comment">//使用oc中定义的协议没有模块</span>
<span class="hljs-function"><span class="hljs-title">XLYMultiCastDelegate</span><span class="hljs-params">(protocolName: <span class="hljs-string">"SimpleProtocol"</span>)</span></span>
<span class="hljs-comment">//使用 swift定义的协议需要加上模块信息, 否则无法获取</span>
<span class="hljs-function"><span class="hljs-title">XLYMultiCastDelegate</span><span class="hljs-params">(protocolName: <span class="hljs-string">"XLYMultiCastDelegateDemo.SimpleSwiftProtocol"</span>)</span></span></code></pre><p>然后在调用时需要用as进行类型转换才能调用方法. </p>
<pre><code class="null hljs"><span class="hljs-symbol">let</span> <span class="hljs-keyword">multiDelegate </span>= <span class="hljs-keyword">multiDelegateUsingOCProtocol </span>as SimpleProtocol</code></pre><p>运行时会使用<code>-[NSObject respondsToSelector:]</code>来进行检查是否可以转换. 转换成功后就可以进行调用了.</p>
<pre><code class="null hljs"><span class="hljs-selector-tag">multiDelegate</span><span class="hljs-selector-class">.someOptionalMethod</span>!()</code></pre><h3 id="-">总结</h3>
<p>消息转发机制由语言支持, 应该是受到了smalltalk的影响, ruby也有类似的机制. swift想要做成一个类型安全的语言, 支持太多动态的特性会让很多东西失去保证. 总之, 工欲善其事, 必先利其器. 多了解一些语言的特性, 能够学到一些技术的设计思路, 还能帮助简化程序设计, 同时提高逼格😜.</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2014/10/10/XLYMultiCastDelegate/" data-id="cimn48pan000b1cfyodnux6yc" class="article-share-link">分享</a><div class="tags"><a href="/tags/iOS/">iOS</a><a href="/tags/GitHub/">GitHub</a></div><div class="post-nav"><a href="/2014/10/14/iOS_present_introduce_and_points/" class="pre">iOS present 场景切换的演化和要点</a><a href="/2014/10/09/XLYMapping_System/" class="next">XLYMapping System</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/日常/">日常</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/XCode/" style="font-size: 15px;">XCode</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/年终总结/" style="font-size: 15px;">年终总结</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/03/15/年后小总结/">2016 年后小总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/08/XLYAutoLayoutEasy/">XLYAutoLayoutEasy</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/08/talk_about_autolayout/">AutoLayout的小吐槽</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/14/iOS_present_introduce_and_points/">iOS present 场景切换的演化和要点</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/10/XLYMultiCastDelegate/">XLYMultiCastDelegate 多播代理</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/09/XLYMapping_System/">XLYMapping System</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/06/17/difference_between_debug_run_and_Archive_run/">iOS 编译运行部署和发布部署的一个差异</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/06/10/objective-c_coding_guidelines_translation/">Coding Guidelines for Cocoa 翻译</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/06/10/Objective-C Resolve Method/">Objective-C Resolve Method</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">kaizei.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>