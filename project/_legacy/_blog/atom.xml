<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kaizeiとyimi</title>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2016-05-26T09:44:28.000Z</updated>
  <id>/</id>
  
  <author>
    <name>kaizei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对swift中单例的init搞破坏</title>
    <link href="/2016/05/26/break-swift-init-rule/"/>
    <id>/2016/05/26/break-swift-init-rule/</id>
    <published>2016-05-26T03:41:02.000Z</published>
    <updated>2016-05-26T09:44:28.000Z</updated>
    
    <content type="html">&lt;p&gt;swift的init方法十分严格, 需要先初始化自己声明的属性, 然后调用super.init, 最后做其他事情. init方法中不允许对象在没有初始化所有属性之前被作为参数使用. 但是我们有办法打破这个规则.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;虽然能打破规则, 但是程序也会卡住, 所以并没有什么x用.&lt;/p&gt;
&lt;p&gt;show you the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; sharedInstance = &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()
    &lt;span class=&quot;hljs-keyword&quot;&gt;init&lt;/span&gt;() {
        test()
    }
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;enter&quot;&lt;/span&gt;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;_&lt;/span&gt; = &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;.sharedInstance
    &lt;span class=&quot;hljs-built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;exit&quot;&lt;/span&gt;)
}

&lt;span class=&quot;hljs-comment&quot;&gt;// first&lt;/span&gt;
&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;.sharedInstance

&lt;span class=&quot;hljs-comment&quot;&gt;// second&lt;/span&gt;
test()&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;两种方式都一样, 都不会有&lt;code&gt;exit&lt;/code&gt;的输出, 只是第二种会打印两次&lt;code&gt;enter&lt;/code&gt;而已.&lt;/p&gt;
&lt;p&gt;引发的问题的步骤是在&lt;code&gt;init&lt;/code&gt;方法中调用一个不需要传递self作为参数的方法比如&lt;code&gt;test&lt;/code&gt;, 这样就能编译通过, 然后在该方法里面访问单例. 只要调用&lt;code&gt;test&lt;/code&gt;的&lt;code&gt;init&lt;/code&gt;方法和单例初始化调用的&lt;code&gt;init&lt;/code&gt;方法是同一个就一定会出问题.&lt;/p&gt;
&lt;p&gt;以上调用导致&lt;code&gt;A&lt;/code&gt;在初始化过程中被引用, 而引用时&lt;code&gt;A&lt;/code&gt;的初始化方法还没有返回, 对象还没有初始化完成. &lt;/p&gt;
&lt;p&gt;然后整个线程就挂住了, CPU和内存利用率都不会有什么起伏. 在后台线程线程确认了一下, &lt;code&gt;MainRunloop&lt;/code&gt;并没有在waiting. 当然, 任何一个线程访问&lt;code&gt;A.sharedInstance&lt;/code&gt;都会导致那个线程卡住.&lt;/p&gt;
&lt;p&gt;swift编译器对于这种问题应该不好查, 不过我倒是觉得运行时应该能检测到对象没初始化完成就被引用了, 然后给个crash, 而不是现在这样默默干等.&lt;/p&gt;
&lt;p&gt;如果写单例, 注意一点儿哦~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;swift的init方法十分严格, 需要先初始化自己声明的属性, 然后调用super.init, 最后做其他事情. init方法中不允许对象在没有初始化所有属性之前被作为参数使用. 但是我们有办法打破这个规则.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="swift" scheme="/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>the Twenty of May</title>
    <link href="/2016/05/20/the-Twenty-of-May/"/>
    <id>/2016/05/20/the-Twenty-of-May/</id>
    <published>2016-05-20T15:32:27.000Z</published>
    <updated>2016-05-20T16:24:41.000Z</updated>
    
    <content type="html">&lt;p&gt;一首歌叫&lt;strong&gt;first of may&lt;/strong&gt;, 讲述一个爱情故事, 学友翻唱出来别有滋味. 今天是20th of May, 520的日子, 却有另一番滋味.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;不要乱猜, 我刚办完婚礼, 去了趟普吉岛也回来了. 晚上和媳妇吃了个团购的日料, 小酌了一杯梅酒, 日子滋润着呢. 然后也聊了一下那另有的一番滋味: 公司挂了. &lt;/p&gt;
&lt;p&gt;去年8月来, 虽然是个小创业公司, 但一直工作得很开心, 今天CEO跟我们说因为各种原因, 资金不给力了, 我们要散了.&lt;/p&gt;
&lt;p&gt;其实没有特别震惊, 最近这一个月也发生了一些事情, 让我们多少也有些心理准备, 就是觉得挺可惜的, 产品上有不错的点, 团队的技术也挺棒的, 虽然8月才来, 也学到了许多, 也创造了许多, 总之还是很感谢公司的.&lt;/p&gt;
&lt;p&gt;晚上跟我的小伙伴们说了这一情况后真是足足地感受到了温暖, 大家非常关心我, 对我真的太好了. 真是人间有真情, 人间有真爱啊~&lt;/p&gt;
&lt;p&gt;我的人生多了这么一个经历, 我的心情是什么? 叹口气: 可惜了.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一首歌叫&lt;strong&gt;first of may&lt;/strong&gt;, 讲述一个爱情故事, 学友翻唱出来别有滋味. 今天是20th of May, 520的日子, 却有另一番滋味.&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="心情" scheme="/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>复用内部公用代码的几种方式</title>
    <link href="/2016/05/19/reuse-internal-codes/"/>
    <id>/2016/05/19/reuse-internal-codes/</id>
    <published>2016-05-19T13:20:43.000Z</published>
    <updated>2016-05-20T15:21:50.000Z</updated>
    
    <content type="html">&lt;p&gt;一般来讲, 总是会有一些内部私有代码是有复用价值的, 比如一些Utils方法, 一些公用的UI组件, 一些对各种框架或者库的封装. 本文介绍几种复用的方式, 分别是使用多target, 使用workspace集成多个project, 以及利用cocoapods来集成私有代码. 每种方式都各有利弊, 没有最好, 只有合适.
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设我们已经知道哪些代码是公用的, 并且已经拆分完毕, 现在我们有多个逻辑模块, 一个是&lt;code&gt;Common&lt;/code&gt;表示公用的代码, 其他是&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;等, 表示依赖&lt;code&gt;Common&lt;/code&gt;的模块. 为了方便, &lt;code&gt;Common&lt;/code&gt;简写为&lt;code&gt;C&lt;/code&gt;, 而且假设上层模块只有&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;, 公用代码只有一个&lt;code&gt;C&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;稍微有点儿样子的工程, &lt;code&gt;C&lt;/code&gt;一般都是有第三库依赖的, 也就是说&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;都有各自的第三方库依赖, 如何处理依赖冲突也是需要考虑的.&lt;/p&gt;
&lt;h1 id=&quot;一个repo管理&quot;&gt;&lt;a href=&quot;#一个repo管理&quot; class=&quot;headerlink&quot; title=&quot;一个repo管理&quot;&gt;&lt;/a&gt;一个repo管理&lt;/h1&gt;&lt;p&gt;一个project多target, 和一个workspace多project没有太大区别, 这里讨论放在一个repo里面管理的情况. 多个repo的情况就需要用git submodule, 更新比较麻烦, 后文再谈.&lt;/p&gt;
&lt;h3 id=&quot;多target&quot;&gt;&lt;a href=&quot;#多target&quot; class=&quot;headerlink&quot; title=&quot;多target&quot;&gt;&lt;/a&gt;多target&lt;/h3&gt;&lt;p&gt;XCode支持在一个project中创建多个target, 我们可以把&lt;code&gt;C&lt;/code&gt;的代码放置到&lt;code&gt;targetC&lt;/code&gt;中, &lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;的代码分别放置到&lt;code&gt;targetA&lt;/code&gt;和&lt;code&gt;targetB&lt;/code&gt;中. &lt;code&gt;targetC&lt;/code&gt;配置为输出framework或者static lib, 而&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;都链接&lt;code&gt;targetC&lt;/code&gt;. &lt;/p&gt;
&lt;h3 id=&quot;多project&quot;&gt;&lt;a href=&quot;#多project&quot; class=&quot;headerlink&quot; title=&quot;多project&quot;&gt;&lt;/a&gt;多project&lt;/h3&gt;&lt;p&gt;Xcode也提供了多个工程整合的方式, 即使用workspace. 我们把3个模块的代码放置到3个不同的工程, 然后都添加到同一个workspace中, &lt;code&gt;C&lt;/code&gt;仍然输出framework或者static lib, &lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;需要动点儿手脚才能正确添加&lt;code&gt;C.framework&lt;/code&gt;作为其embed framework.&lt;/p&gt;
&lt;p&gt;估计是xcode的bug, 添加embed framework时路径是绝对路径, 不过可以直接编辑工程文件来修改, 也可以绕一下, 让&lt;code&gt;C&lt;/code&gt;编译完成后copy包到某一个相对路径, 比如&lt;code&gt;C&lt;/code&gt;的工程目录下, 然后再引入此包. 这样不管什么scheme编译完成都会直接覆盖此包, 保持最新. &lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;还需要配置一下scheme来保证每次build前都要先build &lt;code&gt;C&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;此种方法最简单, 更新代码的时候非常方便, &lt;code&gt;C&lt;/code&gt;中开发了新代码, 可单元测试, 也可立即和&lt;code&gt;A&lt;/code&gt;或者&lt;code&gt;B&lt;/code&gt;联调, 因为它们在一个repo里面, 所有改动都是立即可见的. 这一点对代码持续演进和集成非常友好.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C&lt;/code&gt;有自己的第三库依赖, 我们一般采用cocoapods管理, 这里比较特殊的一点是&lt;code&gt;C&lt;/code&gt;自己也是个lib, 当我们用framework时不能在&lt;code&gt;C.framework&lt;/code&gt;中嵌套embed的framework, 可以观察&lt;code&gt;targetC&lt;/code&gt;的build phase, 并没有&lt;code&gt;Embed Pods Frameworks&lt;/code&gt;. 就算我们手动加上, 也就模拟器能正常, build到设备上依然要挂, 提示&lt;code&gt;no suitable image found&lt;/code&gt;, 然后巴拉巴拉. 所以我们需要考虑解决依赖的问题. 目前cocoapods已经发布1.0版本, 我的解决办法是使用&lt;code&gt;abstract_target&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;ruby hljs&quot;&gt;abstract_target &lt;span class=&quot;hljs-string&quot;&gt;&#39;common&#39;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;
    pod &lt;span class=&quot;hljs-string&quot;&gt;&#39;Alamofire&#39;&lt;/span&gt;
    pod &lt;span class=&quot;hljs-string&quot;&gt;&#39;RxSwift&#39;&lt;/span&gt; 

    target &lt;span class=&quot;hljs-string&quot;&gt;&#39;A&#39;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;
      workspace &lt;span class=&quot;hljs-string&quot;&gt;&#39;my.workspace&#39;&lt;/span&gt;
      project &lt;span class=&quot;hljs-string&quot;&gt;&#39;A/A.xcodeproj&#39;&lt;/span&gt;
      pod &lt;span class=&quot;hljs-string&quot;&gt;&#39;RxCocoa&#39;&lt;/span&gt;
      pod &lt;span class=&quot;hljs-string&quot;&gt;&#39;XAutoLayout&#39;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;

    target &lt;span class=&quot;hljs-string&quot;&gt;&#39;B&#39;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;
      workspace &lt;span class=&quot;hljs-string&quot;&gt;&#39;my.workspace&#39;&lt;/span&gt;
      project &lt;span class=&quot;hljs-string&quot;&gt;&#39;B/B.xcodeproj&#39;&lt;/span&gt;
      pod &lt;span class=&quot;hljs-string&quot;&gt;&#39;Socket.IO-Client-Swift&#39;&lt;/span&gt;
      pod &lt;span class=&quot;hljs-string&quot;&gt;&#39;XAutoLayout&#39;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;

    target &lt;span class=&quot;hljs-string&quot;&gt;&#39;C&#39;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;
      workspace &lt;span class=&quot;hljs-string&quot;&gt;&#39;my.workspace&#39;&lt;/span&gt;
      project &lt;span class=&quot;hljs-string&quot;&gt;&#39;C/C.xcodeproj&#39;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;common&lt;/code&gt;作为parent target并且是个抽象的, 也就是说不会真正有这么个target存在, 但是parent的身份让内部的&lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;和&lt;code&gt;C&lt;/code&gt;这几个target都继承pod配置. 因此, 这里&lt;code&gt;common&lt;/code&gt;描写&lt;code&gt;C&lt;/code&gt;需要的库, 而不是在C那里单独配置, 否则&lt;code&gt;A&lt;/code&gt;将不能正确处理&lt;code&gt;C&lt;/code&gt;的依赖. &lt;/p&gt;
&lt;p&gt;这里还涉及到依赖的冲突, &lt;code&gt;A&lt;/code&gt;依赖的&lt;code&gt;RxCocoa&lt;/code&gt;依赖了&lt;code&gt;RxSwift&lt;/code&gt;, &lt;code&gt;common&lt;/code&gt;里面也描述了依赖&lt;code&gt;RxSwift&lt;/code&gt;, 继承后只要pod能正确处理冲突就没什么问题.&lt;/p&gt;
&lt;p&gt;最终编译出来的&lt;code&gt;C.framework&lt;/code&gt;只会包含&lt;code&gt;C&lt;/code&gt;这个模块的代码, 依赖的第三方库会在&lt;code&gt;A&lt;/code&gt;或者&lt;code&gt;B&lt;/code&gt;引入.&lt;/p&gt;
&lt;p&gt;如果是使用static lib, 那么&lt;code&gt;C.a&lt;/code&gt;就会包含第三方库的符号表, 再以此集成到其他target, 这样就不能用abstract_target, 而应该小心地避免符号表冲突. 而当遇到类似&lt;code&gt;A&lt;/code&gt;依赖的&lt;code&gt;RxCocoa&lt;/code&gt;需要依赖&lt;code&gt;RxSwift&lt;/code&gt;, 而&lt;code&gt;C&lt;/code&gt;也要依赖&lt;code&gt;RxSwift&lt;/code&gt;时, 就只能把&lt;code&gt;RxCocoa&lt;/code&gt;作为&lt;code&gt;C&lt;/code&gt;的依赖来处理, 否则&lt;code&gt;RxSwift&lt;/code&gt;将出现符号表冲突. 所以还是用framework吧.&lt;/p&gt;
&lt;h3 id=&quot;开发流程&quot;&gt;&lt;a href=&quot;#开发流程&quot; class=&quot;headerlink&quot; title=&quot;开发流程&quot;&gt;&lt;/a&gt;开发流程&lt;/h3&gt;&lt;p&gt;大家都在一个repo, 原则上我们提交一个patch需要保证每个模块都正常编译, 因此当&lt;code&gt;C&lt;/code&gt;有改动要提交, 我们需要所有模块上都能测试通过. 当&lt;code&gt;A&lt;/code&gt;要开发新需求, 我们创建一个&lt;code&gt;devA&lt;/code&gt;的branch, 然后&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;C&lt;/code&gt;都有改动, 甚至一些&lt;code&gt;C&lt;/code&gt;的改动还导致&lt;code&gt;B&lt;/code&gt;也需要改动, 虽然这个时候并不是为了开发&lt;code&gt;B&lt;/code&gt;. &lt;code&gt;B&lt;/code&gt;也有&lt;code&gt;devB&lt;/code&gt;在开发, 改动&lt;code&gt;C&lt;/code&gt;时也有可能导致&lt;code&gt;A&lt;/code&gt;被改动. &lt;/p&gt;
&lt;p&gt;合并需要及时, 如果&lt;code&gt;devA&lt;/code&gt;开发完毕了应尽早合并回主分支, 然后再继续从主分支合并到&lt;code&gt;devB&lt;/code&gt;, 此时需要解决一些冲突. 这些冲突里面就会包含在&lt;code&gt;devA&lt;/code&gt;和&lt;code&gt;devB&lt;/code&gt;中对&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;进行的不同的修改, 哪怕只是当时为了编译通过的修改都有可能和另一个分支冲突.&lt;/p&gt;
&lt;p&gt;如果在同一个&lt;code&gt;dev&lt;/code&gt;分支上进行&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;的开发, 只要任何时候有实验性质的feature要尝试, 就需要多个分支, 实际上现实生活中不可能只有一个dev分支的, 因此上述合并分支的问题总是需要考虑的. &lt;/p&gt;
&lt;p&gt;导致冲突增加, 合并复杂的原因主要是3个模块在一个repo相互不独立, 提交patch时是同时影响多个模块, 而且我们要贯彻提交patch保证编译通过的原则, 因此一些可以滞后的合并和修改就被提前了, 并且这种提前并不总是有效的.&lt;/p&gt;
&lt;p&gt;如果不贯彻编译通过再提交的原则将引起更多的问题, 这个就不用多解释了.&lt;/p&gt;
&lt;h2 id=&quot;多个repo管理&quot;&gt;&lt;a href=&quot;#多个repo管理&quot; class=&quot;headerlink&quot; title=&quot;多个repo管理&quot;&gt;&lt;/a&gt;多个repo管理&lt;/h2&gt;&lt;p&gt;如果将这些模块分散到多个repo, 各自提交patch, 则需要一些手段才能将他们相互关联起来. 这里讨论使用cocoapods和git submodule. 使用cocoapods又分为两种用法, 分别是用私有spec repo来记录&lt;code&gt;C&lt;/code&gt;的各个tag版本, 以及直接指定&lt;code&gt;C&lt;/code&gt;的branch和commit.&lt;/p&gt;
&lt;h3 id=&quot;私有spec-repo-tag发版&quot;&gt;&lt;a href=&quot;#私有spec-repo-tag发版&quot; class=&quot;headerlink&quot; title=&quot;私有spec repo + tag发版&quot;&gt;&lt;/a&gt;私有spec repo + tag发版&lt;/h3&gt;&lt;p&gt;如果&lt;code&gt;C&lt;/code&gt;比较独立, 真的不涉及多少业务逻辑, 变化频率不高, 和&lt;code&gt;A&lt;/code&gt; &lt;code&gt;B&lt;/code&gt;的联调需求很小, 我觉得可以考虑让&lt;code&gt;C&lt;/code&gt;单独开发, 并在需要的时候发版. 不用完全跟着&lt;code&gt;A&lt;/code&gt;或者&lt;code&gt;B&lt;/code&gt;的节奏走.&lt;/p&gt;
&lt;p&gt;第一次创建的流程如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt;要先写好一个&lt;code&gt;podspec&lt;/code&gt;文件, 描述了自己如何被集成, 并指定了source为某一个tag号. &lt;/li&gt;
&lt;li&gt;发布&lt;code&gt;C&lt;/code&gt;到私有spec repo中.&lt;/li&gt;
&lt;li&gt;所有team member更新&lt;code&gt;C&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之后更新&lt;code&gt;C&lt;/code&gt;的时候只需给新的code打tag, 然后重复步骤2和3就好了. pod在install或者update的时候都会check缓存, 如果更新code后不更新tag将会使用cache的代码, 新代码是下不来的. 当然也可以把原来的tag删掉, 重新打一样的, 然后删掉pod的cache再update, 不过这看起来很无趣.&lt;/p&gt;
&lt;p&gt;如果一切都像想的那么好就真的太好了. 我们肯定会遇到&lt;code&gt;C&lt;/code&gt;的更新导致&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;需要修改的情况, 如何联调测试? 他们都不在一个repo了, 所以我们需要都下载下来, 但是问题是&lt;code&gt;C&lt;/code&gt;要发版才能被pod更新, 因此我们就需要打很多无用的tag来不停地循环:提交代码 -&amp;gt; 发布&lt;code&gt;C&lt;/code&gt; -&amp;gt; 更新&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt; -&amp;gt; 调试 -&amp;gt; 修改代码 -&amp;gt; 提交代码. 终于调试完毕了, 然后删掉那一堆没用的tag. &lt;/p&gt;
&lt;p&gt;除非用一个其他方式来在开发&lt;code&gt;C&lt;/code&gt;的电脑上集成&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;, 如何考虑到要分散到各个repo的话, 估计就只能用submodule+workspace集成了. 这个后文再谈.&lt;/p&gt;
&lt;h3 id=&quot;直接指定branch-commit&quot;&gt;&lt;a href=&quot;#直接指定branch-commit&quot; class=&quot;headerlink&quot; title=&quot;直接指定branch + commit&quot;&gt;&lt;/a&gt;直接指定branch + commit&lt;/h3&gt;&lt;p&gt;pod支持直接指定这两者来下载code, 所以我们只要保证&lt;code&gt;C&lt;/code&gt;的repo能访问就可以了, 不需要创建私有spec repo. 这种方式的branch + commit 的作用跟tag一样, 目的都是为了指向一个不可变的代码集. 集成&lt;code&gt;C&lt;/code&gt;也很简单, 只要&lt;code&gt;C&lt;/code&gt;的repo先准备好, 并且repo里面有&lt;code&gt;podspec&lt;/code&gt;文件.&lt;/p&gt;
&lt;p&gt;这里有个小限制, &lt;code&gt;podspec&lt;/code&gt;里面指定的source一定要能访问, 否则pod检查过不了, 但是然并卵, 我们在podfile里面指定了branch和commit, pod就会从我们指定的位置下载repo, 读取&lt;code&gt;podspec&lt;/code&gt;并忽略掉source配置.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C&lt;/code&gt;更新代码的时候, 如果&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;需要跟进, 则更新一下branch和commit就好, 如果忽略掉commit, 将默认是HEAD. 我们可以利用这点来简化开发流程.&lt;/p&gt;
&lt;p&gt;我们采用这种方式是考虑到&lt;code&gt;C&lt;/code&gt;的更新驱动&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;更新时, 使用tag方式带来的各种不爽. 假设基本配置都已经完成, 进入了一个稳定状态. 之后的开发流程如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;新建branch &lt;code&gt;devA&lt;/code&gt;进行开发, 由于需要改动&lt;code&gt;C&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;也创建了branch &lt;code&gt;devC&lt;/code&gt;. &lt;/li&gt;
&lt;li&gt;联调的次数比较多, 在&lt;code&gt;devA&lt;/code&gt;上将&lt;code&gt;podfile&lt;/code&gt;中指向的&lt;code&gt;C&lt;/code&gt;去掉commit, 仅保留branch信息指向&lt;code&gt;devC&lt;/code&gt;, 这样默认就是使用&lt;code&gt;devC&lt;/code&gt;的最新代码, 然后每次改动&lt;code&gt;C&lt;/code&gt;以后就update一下, &lt;code&gt;A&lt;/code&gt;就能获取到最新的代码.&lt;/li&gt;
&lt;li&gt;开发完毕后, &lt;code&gt;C&lt;/code&gt;先合并回主分支, 并记录下commit, 然后&lt;code&gt;A&lt;/code&gt;再合并, 并在&lt;code&gt;podfile&lt;/code&gt;中修改branch为&lt;code&gt;C&lt;/code&gt;的主分支以及添加commit信息.&lt;/li&gt;
&lt;li&gt;如果处于2状态的时候&lt;code&gt;B&lt;/code&gt;也要开发, 可以让&lt;code&gt;C&lt;/code&gt;从最开始的稳定状态再branch一个分支&lt;code&gt;devC2&lt;/code&gt;, 也如2那般开发.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;合并完成后, 需要将&lt;code&gt;C&lt;/code&gt;的主分支再合并到&lt;code&gt;devC2&lt;/code&gt;以跟进最新改动.&lt;/li&gt;
&lt;li&gt;步骤4中也可不创建新分支, 而直接引用&lt;code&gt;devC&lt;/code&gt;进行开发.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里着重讨论一下4和6的问题. 如果&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;引用同一个&lt;code&gt;C&lt;/code&gt;的dev分支, 就能够非常及时地用上新code并且不用重新开发, 不过这又会导致&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;互相推着对方走. 如果引用不同的分支, 则&lt;code&gt;devC&lt;/code&gt;上开发的新功能想要在&lt;code&gt;devC2&lt;/code&gt;上用, 就需要merge或者cherry-pick一下, 但如果这样做会引入新问题的话, 则只能重新实现一下了. &lt;/p&gt;
&lt;p&gt;引用不同的&lt;code&gt;C&lt;/code&gt;的分支, 则整个结构和用workspace的方案很像, 分支的管理也基本一样. 区别就是workspace方案不能单独让&lt;code&gt;C&lt;/code&gt;的代码回退, 换个说法就是没办法指定使用某个版本的&lt;code&gt;C&lt;/code&gt;, 因为大家的patch是交叠在一起的, 回退某一个模块几乎是不可能的.&lt;/p&gt;
&lt;p&gt;依赖的解决比较简单, &lt;code&gt;podspec&lt;/code&gt;中描述好依赖就好, pod会自动解决.&lt;/p&gt;
&lt;h3 id=&quot;git-submodule&quot;&gt;&lt;a href=&quot;#git-submodule&quot; class=&quot;headerlink&quot; title=&quot;git submodule&quot;&gt;&lt;/a&gt;git submodule&lt;/h3&gt;&lt;p&gt;&lt;code&gt;A&lt;/code&gt;的repo用submodule引用&lt;code&gt;C&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;也一样. 然后用子工程或者workspace来集成&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;C&lt;/code&gt;的工程. 这样做并没有解决太多问题, 因为用submodule, &lt;code&gt;C&lt;/code&gt;的更新每次都需要&lt;code&gt;A&lt;/code&gt;或者&lt;code&gt;B&lt;/code&gt;提交一个跟进的patch, 切换分支和更新&lt;code&gt;C&lt;/code&gt;什么的也挺麻烦. 而且还需要多考虑一个依赖的问题. &lt;/p&gt;
&lt;p&gt;如果不用pod来集成&lt;code&gt;C&lt;/code&gt;, 那么&lt;code&gt;C&lt;/code&gt;的依赖怎么添加到&lt;code&gt;A&lt;/code&gt;中? 手动解决将十分麻烦了. 仅剩的一个方案就是用&lt;code&gt;development Pod&lt;/code&gt;, 让&lt;code&gt;podfile&lt;/code&gt;里面的&lt;code&gt;C&lt;/code&gt;使用path指向submodule的路径, 这样仍然需要写一个&lt;code&gt;podspec&lt;/code&gt;文件来描述&lt;code&gt;C&lt;/code&gt;的集成. pod在引用development pod时有点儿tricky, 它没有copy而是引用, 因此当更新&lt;code&gt;C&lt;/code&gt;里面的代码时是立即可以用的, 不需要update. 只有当创建或者删除了文件时才需要update一下. 另外因为是用submodule, 每次&lt;code&gt;C&lt;/code&gt;更新后都需要尽快到&lt;code&gt;A&lt;/code&gt;中提交一个patch以记录&lt;code&gt;C&lt;/code&gt;的更新, 还有一系列submodule的坑等在后面, 就不多说了. 总之是不推荐使用submodule.&lt;/p&gt;
&lt;h2 id=&quot;总结-7&quot;&gt;&lt;a href=&quot;#总结-7&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;一张表概述一下:&lt;/p&gt;
&lt;div&gt;&lt;div class=&quot;table_container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方案&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;th&gt;建议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;targets &amp;amp; workspace&lt;/td&gt;
&lt;td&gt;代码更新和调试友好&lt;/td&gt;
&lt;td&gt;所有模块共进退&lt;/td&gt;
&lt;td&gt;适合模块数量少, 更新较频繁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;private pod using tags&lt;/td&gt;
&lt;td&gt;版本控制良好&lt;/td&gt;
&lt;td&gt;代码更新和调试较麻烦&lt;/td&gt;
&lt;td&gt;适合模块数量多, 更新不那么频繁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;private pod using branch &amp;amp; commit&lt;/td&gt;
&lt;td&gt;版本控制良好&lt;/td&gt;
&lt;td&gt;代码更新和调试还能忍受&lt;/td&gt;
&lt;td&gt;适合模块数量多, 更新频率一般&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;文中的规模是很容扩展的, 比如有多个上层模块和多个公共模块, 需要思考的点都是一样的:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何集成&lt;/li&gt;
&lt;li&gt;如何开发和联调&lt;/li&gt;
&lt;li&gt;如何将公共模块的改动恰当地同步到各个上层模块&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然, 如果模块数量很少, 代码量也不大, 模块共进退在项目早期也是可以接受的, 采用上述的各种方案都是可以很方便地迁移到其他方案的. 还有一点, 毕竟公共代码存在的目的就是为了被公用, 如果不是所有代码都公用那公共代码为什么还叫公共代码? 所以大家在考虑如何选择复用方案的时候一定不要忘了这点, 不要把问题想得过于复杂.&lt;/p&gt;
&lt;p&gt;本文主要是记录一下我自己的思考过程, 总结不到位或者有错的地方还请见谅.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一般来讲, 总是会有一些内部私有代码是有复用价值的, 比如一些Utils方法, 一些公用的UI组件, 一些对各种框架或者库的封装. 本文介绍几种复用的方式, 分别是使用多target, 使用workspace集成多个project, 以及利用cocoapods来集成私有代码. 每种方式都各有利弊, 没有最好, 只有合适.
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="cocoapods" scheme="/tags/cocoapods/"/>
    
      <category term="workspace" scheme="/tags/workspace/"/>
    
  </entry>
  
  <entry>
    <title>make AutoLayout X</title>
    <link href="/2016/04/17/make-AutoLayout-X/"/>
    <id>/2016/04/17/make-AutoLayout-X/</id>
    <published>2016-04-17T03:34:24.000Z</published>
    <updated>2016-05-20T15:27:29.000Z</updated>
    
    <content type="html">&lt;p&gt;其实挺不好意思的, 2年前的知识, 半年前的库, 现在才写下来. sigh...&lt;/p&gt;
&lt;p&gt;简单说来就是一个小库: &lt;a href=&quot;https://github.com/kaizeiyimi/XAutoLayout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XAutoLayout&lt;/a&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;陈年旧事&quot;&gt;&lt;a href=&quot;#陈年旧事&quot; class=&quot;headerlink&quot; title=&quot;陈年旧事&quot;&gt;&lt;/a&gt;陈年旧事&lt;/h2&gt;&lt;p&gt;以前我吐槽了约束写起来太费劲, 布局很手动化, 几乎需要非常详细地指明每一个约束的每一个条件. 而这样的结果就是代码非常长, 阅读和理解都好困难, 看着打瞌睡. VFL? no kidding me again. &lt;/p&gt;
&lt;p&gt;反正好麻烦, 然后开源社区出现了一个库&lt;strong&gt;Masonry&lt;/strong&gt;, 目的是简化代码写约束, 提供了链式语法以及一些helper方法. 当然本文不是要介绍它, 也不是要批评它, 只是吐槽而已, 后文再说. 本文主要是介绍我写的&lt;strong&gt;XAutoLayout&lt;/strong&gt;😃. &lt;/p&gt;
&lt;h2 id=&quot;demo-code&quot;&gt;&lt;a href=&quot;#demo-code&quot; class=&quot;headerlink&quot; title=&quot;demo code&quot;&gt;&lt;/a&gt;demo code&lt;/h2&gt;&lt;p&gt;使用起来还是比较方便的. 我定义了几个操作符&lt;code&gt;=/&lt;/code&gt;,&lt;code&gt;&amp;lt;=/&lt;/code&gt;和&lt;code&gt;&amp;gt;=/&lt;/code&gt;, 分别与&lt;strong&gt;xEqual&lt;/strong&gt;, &lt;strong&gt;xLessOrEqual&lt;/strong&gt;, &lt;strong&gt;xGreaterOrEqual&lt;/strong&gt;这几个方法等价, array仅支持&lt;code&gt;=/&lt;/code&gt;, 对应的方法是&lt;code&gt;xEqual&lt;/code&gt;的另一重载. 所有内部实现都没有使用定义的操作符.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;xmakeConstraints(.&lt;span class=&quot;hljs-type&quot;&gt;RightToLeft&lt;/span&gt;, autoActive = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;) {  &lt;span class=&quot;hljs-comment&quot;&gt;// autoActive has a default value true&lt;/span&gt;
    v1.xEdge =/ [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,-&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,-&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// can directly use number, the second view will be superview&lt;/span&gt;
    v2.xSize =/ [&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;, view.heightAnchor.xc(-&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;)] &lt;span class=&quot;hljs-comment&quot;&gt;// can use iOS9 API&lt;/span&gt;

    &lt;span class=&quot;hljs-comment&quot;&gt;// [v2.xTop, v2.xLeading] =/ [20, 10]  same as the below two lines&lt;/span&gt;
    v2.xTop =/ &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;
    v2.xLeading =/ &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;面向接口编程&quot;&gt;&lt;a href=&quot;#面向接口编程&quot; class=&quot;headerlink&quot; title=&quot;面向接口编程&quot;&gt;&lt;/a&gt;面向接口编程&lt;/h2&gt;&lt;p&gt;这个应该是swift最强调的了. 面向接口编程是大家都懂, 但又一般不这么干的一个编程准则. swift2以后给protocol加上了extension提供默认实现的能力, 让面向接口编程更加强大. 加上对之前写过的那个库不满意, 于是决定充分利用语言能力用纯swift重写一个. &lt;/p&gt;
&lt;p&gt;iOS9新增了一些&lt;code&gt;topAnchor&lt;/code&gt;这样的API, 用来封装&lt;code&gt;item&lt;/code&gt;和&lt;code&gt;attr&lt;/code&gt;, 用起来比以前直观一些. 但是现在市面上更多的是base到iOS7, 有些是到iOS8, 这样的API就只能远观了. 虽然方便了一些, 但是因为这些东西还要考虑OC, 导致实际使用时看起来仍然比较冗长.&lt;/p&gt;
&lt;h4 id=&quot;想法的建立&quot;&gt;&lt;a href=&quot;#想法的建立&quot; class=&quot;headerlink&quot; title=&quot;想法的建立&quot;&gt;&lt;/a&gt;想法的建立&lt;/h4&gt;&lt;p&gt;一个约束到底要表达什么? 文档中的等式是这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;first&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;attr&lt;/span&gt; = second.&lt;span class=&quot;hljs-built_in&quot;&gt;attr&lt;/span&gt; * m + c&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以这样去拆分:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;firstItem, firstAttribute&lt;/li&gt;
&lt;li&gt;secondItem, secondAttribute&lt;/li&gt;
&lt;li&gt;relation &lt;/li&gt;
&lt;li&gt;multiplier &amp;amp; constant &amp;amp; priority&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于倍数,偏移量和优先级都默认的情况可以这样书写:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;  &lt;span class=&quot;hljs-selector-tag&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.attr&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.relation&lt;/span&gt;(&lt;span class=&quot;hljs-selector-tag&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.attr&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要配置上述4里面的内容怎么书写呢? 有两种想法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// first type&lt;/span&gt;
  &lt;span class=&quot;hljs-built_in&quot;&gt;first&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;attr&lt;/span&gt;.relation(second.&lt;span class=&quot;hljs-built_in&quot;&gt;attr&lt;/span&gt;).m(&lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;).c(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;).p(&lt;span class=&quot;hljs-number&quot;&gt;750&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样写看起来不错. 但是有两个问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链式表达式导致最终返回的仍然是一个我们自定义的对象, 想要拿到&lt;code&gt;NSLayoutConstraint&lt;/code&gt;对象还需要再&lt;code&gt;.constraint&lt;/code&gt;一下.&lt;/li&gt;
&lt;li&gt;对复合类型不友好. 就是demo中看到的对Array使用&lt;code&gt;=/&lt;/code&gt;的情况. 两个array是zip起来后遍历创建约束, 这时候只有两个参数, 不好配置m, c, p.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此就变通了一下书写方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// second type&lt;/span&gt;
  first&lt;span class=&quot;hljs-selector-class&quot;&gt;.attr&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.relation&lt;/span&gt;(second&lt;span class=&quot;hljs-selector-class&quot;&gt;.attr&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.m&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;).c(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;).p(&lt;span class=&quot;hljs-number&quot;&gt;750&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是把第4项的m, c, p 和 第二项的item和attribute结合在一起. 这样就演变成了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;A&lt;/span&gt; relation B&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里又有两种做法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A和B分别是两个类型, A可以做左值和右值, B只做右值. 毕竟B带着m, c, p去做左值确实不太好. 但是这样就有个问题, 想要支持直接用数字配置的时候, B怎么表达? 用AnyObject么? &lt;/li&gt;
&lt;li&gt;A和B分别是两个protocol, 这样避免了AnyObject的问题, 并且能对参数进行约束. 加上swift也是可以给已有类型写extension的, 所以用protocol抽象比较好, 参数不用是AnyObject那么宽泛.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;接口的规划&quot;&gt;&lt;a href=&quot;#接口的规划&quot; class=&quot;headerlink&quot; title=&quot;接口的规划&quot;&gt;&lt;/a&gt;接口的规划&lt;/h4&gt;&lt;p&gt;swift可以给&lt;code&gt;protocol&lt;/code&gt;写&lt;code&gt;extension&lt;/code&gt;来添加方法, Lib里面有一些逻辑不想暴露, 因为protocol extension里面一些方法调用了内部private的API, 并且这些调用会影响实现逻辑.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;XLeftItem&lt;/code&gt;和&lt;code&gt;XRightItem&lt;/code&gt;就分别是A和B, 并且A继承B. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;XRightItem&lt;/code&gt;有一个&lt;code&gt;xGenerateX&lt;/code&gt;方法生成&lt;code&gt;XAttributeX&lt;/code&gt;, 用来包含可选的&lt;code&gt;item&lt;/code&gt;, &lt;code&gt;attr&lt;/code&gt;以及&lt;code&gt;multiplier&lt;/code&gt;,&lt;code&gt;constant&lt;/code&gt;和&lt;code&gt;priority&lt;/code&gt;. 这些属性都不对外暴露, 尽量让调用和接入简单. 况且暴露了的话, 亲不调我的API也能自己玩儿了, 那就没意思啦. 另外通过protocol extension添加了 &lt;code&gt;xm&lt;/code&gt;, &lt;code&gt;xc&lt;/code&gt;, &lt;code&gt;xp&lt;/code&gt;三个方法的默认实现.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XLeftItem&lt;/code&gt;有一个&lt;code&gt;xGenerate&lt;/code&gt;方法生成&lt;code&gt;XAttribute&lt;/code&gt;, 用来包含不为空的&lt;code&gt;item&lt;/code&gt;加&lt;code&gt;attr&lt;/code&gt;. 也通过protocol extension添加了&lt;code&gt;xEqual&lt;/code&gt;, &lt;code&gt;xLessOrEqual&lt;/code&gt; 和 &lt;code&gt;xGreatOrEqual&lt;/code&gt;方法的实现. 这三个方法就是调用了必须调用的内部private API, 嘿嘿.&lt;/li&gt;
&lt;li&gt;那个私有API其实就是调用了&lt;code&gt;XFirstItem&lt;/code&gt;的&lt;code&gt;xGenerate&lt;/code&gt;生成&lt;code&gt;XAtrribute&lt;/code&gt;, 以及&lt;code&gt;XSecondItem&lt;/code&gt;的&lt;code&gt;xGenerateX&lt;/code&gt;生成&lt;code&gt;XAttributeX&lt;/code&gt;, 然后读取两者的信息并做一些调整来生成约束.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;虽然我已经为一些常用的类和protocol写好了extension, 比如&lt;code&gt;NSLayoutAnchor&lt;/code&gt;, &lt;code&gt;UILayoutSupport&lt;/code&gt;还有各种数字类型. 如果亲还有自己想要加入体系的类型, 只需要选择实现&lt;code&gt;XFirstItem&lt;/code&gt;或者&lt;code&gt;XSecondItem&lt;/code&gt;, 再添加&lt;code&gt;xGenerate&lt;/code&gt;或者&lt;code&gt;xGenerateX&lt;/code&gt;方法就可以了. &lt;code&gt;XAttribute&lt;/code&gt;和&lt;code&gt;XAttributeX&lt;/code&gt;都提供了初始化方法, 但是不暴露任何属性. 比如&lt;code&gt;NSLayoutAnchor&lt;/code&gt;的扩展:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@available&lt;/span&gt;(iOS &lt;span class=&quot;hljs-number&quot;&gt;9.0&lt;/span&gt;, *)
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NSLayoutAnchor&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;XLeftItem&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;generateX&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttributeX&lt;/span&gt; {
        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; item = valueForKey(&lt;span class=&quot;hljs-string&quot;&gt;&quot;item&quot;&lt;/span&gt;)!
        &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; attr = &lt;span class=&quot;hljs-type&quot;&gt;NSLayoutAttribute&lt;/span&gt;(rawValue: valueForKey(&lt;span class=&quot;hljs-string&quot;&gt;&quot;attr&quot;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt;! &lt;span class=&quot;hljs-type&quot;&gt;Int&lt;/span&gt;)!
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttributeX&lt;/span&gt;(item: item, attr: attr)
    }
}

v1.xTop =/ v2.bottomAnchor.xc(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后给UIView这样的主角需要的是一些property来表达&lt;code&gt;item + attr&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;UIView&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xLeft: &lt;span class=&quot;hljs-type&quot;&gt;XLeftItem&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt;(item: &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, attr: .&lt;span class=&quot;hljs-type&quot;&gt;Left&lt;/span&gt;) }
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xRight: &lt;span class=&quot;hljs-type&quot;&gt;XLeftItem&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt;(item: &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, attr: .&lt;span class=&quot;hljs-type&quot;&gt;Right&lt;/span&gt;) }
    ... some more
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后&lt;code&gt;UILayoutSupport&lt;/code&gt;也可以轻松加入:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;UILayoutSupport&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xTop: &lt;span class=&quot;hljs-type&quot;&gt;XLeftItem&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt;(item: &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, attr: .&lt;span class=&quot;hljs-type&quot;&gt;Top&lt;/span&gt;) }
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xBottom: &lt;span class=&quot;hljs-type&quot;&gt;XLeftItem&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt;(item: &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, attr: .&lt;span class=&quot;hljs-type&quot;&gt;Bottom&lt;/span&gt;) }
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xHeight: &lt;span class=&quot;hljs-type&quot;&gt;XLeftItem&lt;/span&gt; { &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;XAttribute&lt;/span&gt;(item: &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;, attr: .&lt;span class=&quot;hljs-type&quot;&gt;Height&lt;/span&gt;) }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为一开始就考虑了要支持Array, 所以给UIView也加上了几个复合属性:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;extension&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;UIView&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xSize: [&lt;span class=&quot;hljs-type&quot;&gt;XLeftItem&lt;/span&gt;] {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [xWidth, xHeight]
    }
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; xCenter: [&lt;span class=&quot;hljs-type&quot;&gt;XLeftItem&lt;/span&gt;] {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; [xCenterX, xCenterY]
    }
    ... some more
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但其实可以随意组合, 比如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;[v.xTop,v.xLeading] =/ [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;array里面也能写nil, 表达这个位置不进行配置, 比如:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;v.xEdge =/ [&lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] 
v.xHeight =/ &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就表达了左下右三边紧贴父view, top不配置. 然后再给v设置高度为200.&lt;/p&gt;
&lt;h2 id=&quot;嵌套书写&quot;&gt;&lt;a href=&quot;#嵌套书写&quot; class=&quot;headerlink&quot; title=&quot;嵌套书写&quot;&gt;&lt;/a&gt;嵌套书写&lt;/h2&gt;&lt;p&gt;用&lt;code&gt;xmakeConstraint&lt;/code&gt;创建约束时, 创建的语句是写在闭包里面, 并且还可以控制布局方向和是否自动激活. 也就是说闭包里面的约束是同一组, 接受同样的配置. but how? &lt;/p&gt;
&lt;p&gt;挠挠头, 因为创建约束的过程是内部控制, 我能准确地知道创建的时机, 因此我创建了一个私有上下文对象, 记录一组约束的配置信息, 闭包里面的约束都在这个上下文内根据方向去创建, 并决定是否直接激活. &lt;/p&gt;
&lt;p&gt;因为闭包里面还可以继续嵌套调用&lt;code&gt;xmakeConstraint&lt;/code&gt;, 因此, 上下文需要做成栈, 每一次调用就push一个新的上下文, 调用结束就pop掉.&lt;/p&gt;
&lt;p&gt;系统创建的约束默认是不激活的, 因此, 栈里面默认有一个方向是&lt;strong&gt;LeadingToTrailing&lt;/strong&gt;, 默认不自动激活的上下文. 不在&lt;code&gt;xmakeConstraint&lt;/code&gt;的闭包里, 而是直接裸写的约束才会使用这个上下文. 但这样带来一个小问题, 如果在闭包中调用了一个方法, 方法内部有裸写的约束, 则其实这些看起来裸写的约束也还是处在同一个上下文中. 因此最好都调用&lt;code&gt;xmakeConstraint&lt;/code&gt;来写约束. &lt;/p&gt;
&lt;h2 id=&quot;方向&quot;&gt;&lt;a href=&quot;#方向&quot; class=&quot;headerlink&quot; title=&quot;方向&quot;&gt;&lt;/a&gt;方向&lt;/h2&gt;&lt;p&gt;人类的语言有从左到右, 从右到左, 竖直方向还好都是从上到下. 所以苹果给了3个方向的选择: 分别是LeadingToTrailing, LeftToRight和RightToLeft, 表达是否由系统语言来决定布局方向. 这个参数是在VFL中使用, 而非VFL中是没法使用的. &lt;/p&gt;
&lt;h4 id=&quot;存在的问题-1&quot;&gt;&lt;a href=&quot;#存在的问题-1&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;&gt;&lt;/a&gt;存在的问题&lt;/h4&gt;&lt;p&gt;提到方向就不得不多聊几句. VFL里面指定方向为明确的左到右或者右到左时, 创建出来的约束中, Leading和Trailing会根据方向被直接转换为&lt;strong&gt;Left&lt;/strong&gt;或者&lt;strong&gt;Right&lt;/strong&gt;. 还有一个小问题, 虽然转换了方向, 在计算坐标时仍然是从左向右, 从上到下. 平时使用时一般倍数都是1, 所以不会有啥影响, 只有倍数不为1时才有点儿秀逗. 主要原因是位置计算发生在firstItem和secondItem的最低公共父view的坐标系中, 层级关系不同可能导致参照系不同, 接着导致计算倍数时的基准值不同. 不过一般不建议给位置这样的attribute设置倍数, 否则结果可能完全不是你想象的.&lt;/p&gt;
&lt;p&gt;还有一个变化是iOS9中对水平方向的attribute做了限制. 看一下exception的信息:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; constraint cannot be made between a leading/trailing attribute and a right/left attribute. Use leading/trailing for both or neither.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也正如它所说, 只check水平方向的, 要么都是leading/trailing, 要么都是left/right. 如果是leading和top之类的它就不管... 不过讲真, 拿水平方向和垂直方向的位置属性做约束还是有点儿那啥...&lt;/p&gt;
&lt;h4 id=&quot;属性转换&quot;&gt;&lt;a href=&quot;#属性转换&quot; class=&quot;headerlink&quot; title=&quot;属性转换&quot;&gt;&lt;/a&gt;属性转换&lt;/h4&gt;&lt;p&gt;&lt;code&gt;xmakeConstraint&lt;/code&gt;方法有direction参数, 表达这一组约束的方向信息. 什么时候生效呢? 遵循VFL的做法, 仅当方向不为&lt;strong&gt;LeadingToTrailing&lt;/strong&gt;并且attribute是Leading或者Trailing时才会将attribute转换为Left或者Right.&lt;/p&gt;
&lt;p&gt;当然也不是遇到就转换, 条件还是有的. 再看看系统可能的行为: VFL可以指定方向, 但是受影响的约束的两个attribute肯定是水平方向的Leading/Trailing. 不用VFL时, 可以随意一些, 水平方向的属性可以和垂直方向的或者center等做约束. 也就是不用都是水平方向的属性. 同时iOS针对了少量的几种不配对情况抛出异常.&lt;/p&gt;
&lt;p&gt;为了最大程度和系统行为一致, 创建约束时要先检查attribute是否能配对, lib里面主动抛出的异常就一个, 就是方向不为LeadingToTrailing并且只有一个属性是leading/trailing, 另一个不是水平方向属性. 这种情况下我不知道该不该转换, 而且这种情况用原生API是构造不出来的. 其他不配对的情况lib不处理, 留给iOS来让抛异常提醒你吧.&lt;/p&gt;
&lt;p&gt;如果配对检查过了, 受RightToLeft方向影响的约束需要把constant 乘 -1. &lt;/p&gt;
&lt;h2 id=&quot;扩展数字类型&quot;&gt;&lt;a href=&quot;#扩展数字类型&quot; class=&quot;headerlink&quot; title=&quot;扩展数字类型&quot;&gt;&lt;/a&gt;扩展数字类型&lt;/h2&gt;&lt;p&gt;为了方便, 在设置位置类型的属性时, 可以直接设置数字, 这样secondItem就默认是firstItem的superView, 只要firstItem是一个UIview的话. 这就意味着数字也是&lt;code&gt;XRightItem&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;swift里面有很多种数字类型, 我不得不对每一种都声明extension. 声明一个extension就需要写一次&lt;code&gt;xGenerateX&lt;/code&gt;方法, 看起来好繁琐. 于是沿着这些数字实现的协议链往上找, 最终选择了扩展&lt;code&gt;SignedNumberType&lt;/code&gt; 和 &lt;code&gt;UnsignedIntegerType&lt;/code&gt;来实现&lt;code&gt;xGenerateX&lt;/code&gt;. 这样所有的数字类型就都有了&lt;code&gt;xGenerateX&lt;/code&gt;实现. &lt;/p&gt;
&lt;h2 id=&quot;吐槽Masonry&quot;&gt;&lt;a href=&quot;#吐槽Masonry&quot; class=&quot;headerlink&quot; title=&quot;吐槽Masonry&quot;&gt;&lt;/a&gt;吐槽Masonry&lt;/h2&gt;&lt;p&gt;说实话, 第一次看这个库就觉得做复杂了. 而且一些想法挺奇怪的, 代码中还有一些欠考虑的地方, 分分钟出bug.&lt;/p&gt;
&lt;p&gt;它创建约束的分组想法和我不一样, 它是针对每个view去写一组这个view作为firstItem的约束, 并且制约了裸写约束的可能性, 这样的好处是不用care嵌套的问题, 但是会导致书写的闭包很多.&lt;/p&gt;
&lt;p&gt;它有个&lt;code&gt;MASLayoutConstraint&lt;/code&gt;的类继承自&lt;code&gt;NSLayoutConstraint&lt;/code&gt;,  make时生成的约束全都是这个子类. update和remake方法都只跟自己的体系玩儿, 这些操作只认这个类, 也就是说除非你关于这个view的所有约束都是用Masonry做, 否则update和remake方法没用. 对于有用到storyboard而只想用一个lib来简化部分约束编写的人来说, 只有make那个方法敢用. &lt;/p&gt;
&lt;p&gt;update这个方法会去查询&lt;strong&gt;相似&lt;/strong&gt;的约束, 然后更新这个相似约束的constant而不是激活新的约束. 看Masonry的逻辑, 它把这个概念定义为除了constant以外其他属性全都相同的两个约束是相似的. 但是在AutoLayout里面根本就没有相似这个概念, 所以我觉得不应该生造出这么个概念. 而且约束是双向影响, 下面的两个约束是完全等价的:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;v1.xTop =/ v2.xBottom.xc(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)
v2.xBottom =/ v1.xTop(-&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这在Masonry里面却会被判定为&lt;strong&gt;不相似&lt;/strong&gt;的约束.&lt;/p&gt;
&lt;p&gt; 它的ReadMe里面有这么一句话:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Alternatively if you are only updating the constant value of the constraint you can use the convience method mas_updateConstraints instead of mas_makeConstraints.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际状况是, 如果在一个地方创建, 在另一个地方update, 这两处的first和second必须写得一样才行. 否则哪怕我只是更新constant, 就会因为约束用了另一个等价形式就会激活新的约束与旧的并存. 一般情况下这样都会导致约束冲突, 如果不能自动解决就crash了, 但不管怎样都不是开发者想看到的.&lt;/p&gt;
&lt;p&gt;而且查找相似这个工作本来应该是要递归到window去的, 因为约束不是必须放在最低公共父view上. 不知道是不是因为考虑到了这个效率问题, 才决定只跟自己玩儿, 自己创建的约束, 自己找最低公共父view来激活, 记录下installed view, 然后更新的时候只在这个view上找相似.&lt;/p&gt;
&lt;p&gt;remake方法是删掉有这个view参与的约束然后激活闭包里的约束. 实际使用起来会非常掣肘. 原因主要也是因为Masonry只跟自己玩儿.&lt;/p&gt;
&lt;p&gt;Masonry为了能够支持各个类型的参数, 弄了一个&lt;code&gt;_MASBoxValue&lt;/code&gt;的宏, 利用encoding来对值进行包装并返回id类型. 还用了黑魔法来改变建立关系的方法. 有人觉得挺牛逼的, 我觉得挺不好的. 见仁见智?&lt;/p&gt;
&lt;p&gt;然后对于复合属性的支持也不怎么友好, 内部实现中弄了个delegate来把一个复合变成多个约束, 真心太复杂了. &lt;/p&gt;
&lt;p&gt;总之是觉得Masonry想的太多, 做得不好. 不过有些思路还是可以借鉴的, 比如利用编译器接受无参数有返回值的方法当readonly的property的getter调用这个tricky的地方, 用圆括号和&lt;code&gt;.&lt;/code&gt;实现了链式调用语法.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// no property named test&lt;/span&gt;
-(BlockType)test;

&lt;span class=&quot;hljs-comment&quot;&gt;// can be called like readonly property&lt;/span&gt;
xxx.test();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BlockType如果有参数和返回值, 这个&lt;code&gt;.()&lt;/code&gt;调用的操作就能继续下去. 不过依赖这种编译器的tricky特性总觉得不安全.&lt;/p&gt;
&lt;p&gt;仍然只支持iOS7, 导致不能用8才有的active属性来激活约束. 不过看Masonry的实现, 体系里面对最低公共父view依赖比较多, 就算到8也省不了多少代码.&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;&lt;a href=&quot;#写在最后&quot; class=&quot;headerlink&quot; title=&quot;写在最后&quot;&gt;&lt;/a&gt;写在最后&lt;/h2&gt;&lt;p&gt;everyting start with &lt;code&gt;X&lt;/code&gt;! 好吧, 我的想法也不一定对, 不一定好. 我只是客观地分析了Masonry, 吐槽不对的地方还请看客谅解. 我自己的库也不一定很好用, 虽然我自己一直在用~ &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;其实挺不好意思的, 2年前的知识, 半年前的库, 现在才写下来. sigh...&lt;/p&gt;
&lt;p&gt;简单说来就是一个小库: &lt;a href=&quot;https://github.com/kaizeiyimi/XAutoLayout&quot;&gt;XAutoLayout&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="Github" scheme="/tags/Github/"/>
    
      <category term="swift" scheme="/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>改用hexo了!</title>
    <link href="/2016/04/13/%E6%94%B9%E7%94%A8hexo%E4%BA%86/"/>
    <id>/2016/04/13/改用hexo了/</id>
    <published>2016-04-13T13:12:36.000Z</published>
    <updated>2016-04-14T12:23:40.000Z</updated>
    
    <content type="html">&lt;p&gt;思量再三, 还是不用jekyll了. Ruby什么的累觉不爱, 最关键的是我刚装上最新版就直接不能启动... &lt;/p&gt;
&lt;p&gt;什么? &lt;span style=&quot;color:rgb(179,62,170)&quot;&gt;&lt;strong&gt;没有给空定义match方法&lt;/strong&gt;&lt;/span&gt;. 喂, 还能再详细点儿么? 让我怎么排查问题?&lt;/p&gt;
&lt;p&gt;正好听朋友说&lt;strong&gt;hexo&lt;/strong&gt;, 去䁖了一眼, 用Node做的. 文档真的是...(省略吐槽无数). 擦擦嘴, 喝口水. 其实做得挺不错的, 除了默认主题有点儿丑外加文档很烂以外. &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;折腾了几天, 基于一个主题&lt;a href=&quot;https://github.com/pagecho/maupassant&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;maupassant&lt;/a&gt;进行了不少修改, 删除了大量我不需要的功能, 然后大改css, markdown解析以及高亮. 最后除了页面结构差不多, 其他的都差很多.&lt;/p&gt;
&lt;p&gt;我这也算是自己弄了个主题? &lt;/p&gt;
&lt;p&gt;我觉得hexo不错也许是因为我没有发现jekyll好用. 反正我暂时不会用jekyll了. 刚开始down下来默认模板的时候, 看了一下package, 带了一些category, tag之类的生成器, 一个markdown解析器用的marked, 然后还有个sass解析器的样子. 高亮是用的&lt;strong&gt;highlight.js&lt;/strong&gt;, 这个已经被hexo内置了.&lt;/p&gt;
&lt;h2 id=&quot;其实我还是要吐槽的&quot;&gt;&lt;a href=&quot;#其实我还是要吐槽的&quot; class=&quot;headerlink&quot; title=&quot;其实我还是要吐槽的!!&quot;&gt;&lt;/a&gt;其实我还是要吐槽的!!&lt;/h2&gt;&lt;p&gt;不过槽点并不是很多, 嗯.&lt;/p&gt;
&lt;h3 id=&quot;配置文件&quot;&gt;&lt;a href=&quot;#配置文件&quot; class=&quot;headerlink&quot; title=&quot;配置文件&quot;&gt;&lt;/a&gt;配置文件&lt;/h3&gt;&lt;p&gt;其实我很喜欢&lt;code&gt;gulp&lt;/code&gt;的想法. 扔掉键值对的配置文件, 直接用代码来配置. hexo完全基于Node, 所以为什么不直接用代码来配置? 讲真, 翻看源码的时候看到了一个用代码写好的default config的Object, hexo的逻辑是先加载default config, 然后加载我们的yml写的config文件去覆盖. 真的, 让我们直接写js吧, 最后吐出一个Object就行了, 这样就能完美解决插件配置的问题.&lt;/p&gt;
&lt;h3 id=&quot;marked&quot;&gt;&lt;a href=&quot;#marked&quot; class=&quot;headerlink&quot; title=&quot;marked&quot;&gt;&lt;/a&gt;marked&lt;/h3&gt;&lt;p&gt;首先是markdown解析. 好吧, 本来用marked挺好, 可是呢, marked需要配置啊, 默认的行为当然不是我想要的, 我需要修改它对head, table, code等的解析. 但是这些修改需要修改renderer的方法, 很显然, 这需要code. marked插件的源码我也读了一下, 它会去config对象上获取非常简单的能够用键值对配置的信息, 对于修改renderer无能为力. 因为hexo的做法直接屏蔽了这种可能性.&lt;/p&gt;
&lt;p&gt;于是, 我自己写了插件... sigh. 没有做成npm包的形式, 而是直接在&lt;code&gt;scripts&lt;/code&gt;文件夹里面写了一个简单的js. hexo说这里的脚本会在hexo启动的时候执行.&lt;/p&gt;
&lt;h3 id=&quot;highlight-js&quot;&gt;&lt;a href=&quot;#highlight-js&quot; class=&quot;headerlink&quot; title=&quot;highlight.js&quot;&gt;&lt;/a&gt;highlight.js&lt;/h3&gt;&lt;p&gt;真是欲哭无泪, 没有你这么内置的!! 我都只能用非常规手段去require人家原始的包了. hexo内置后, 也只能配置非常少的高亮信息, 对于需要代码配置的仍然只能干瞪眼. 于是, 我禁掉了配置文件里面的高亮, 在我的简单的小脚本里面(是的, 还是那里)在marked解析code时就把高亮了一起解析了. 于是, 页面终于能够正常处理markdown了.&lt;/p&gt;
&lt;h3 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h3&gt;&lt;p&gt;我... 提起这个我无语凝噎. 这缓存做得, 真是绝了. 反正我又写了个小脚本在hexo要处理文件的时候删这个缓存, 这次没有放在主题里面而是放在hexo主目录里面, 因为我觉得有一天应该会处理掉这个问题, 这个小脚本不应该是主题的一部分.&lt;/p&gt;
&lt;p&gt;当时是这样的. 写了一点儿内容, 改了点儿css的我兴冲冲地调用了一把&lt;code&gt;hexo s -l&lt;/code&gt;. oh, yeah! 页面! 然后我又改了一点儿内容, 刷新. 刷新? 刷新??? 为毛线没有变呢? 看日志是有请求的. 于是我重新启动了server, 还是没变!! 什么情况, 不明真相的我看了看文档, 说有缓存, 删掉试试? 然后就好了. 过了一会儿我再改, 又不给力了. 真的是很无奈, 我并没觉得那个缓存有什么帮助, 删! &lt;/p&gt;
&lt;h2 id=&quot;休息一下-吃根香蕉&quot;&gt;&lt;a href=&quot;#休息一下-吃根香蕉&quot; class=&quot;headerlink&quot; title=&quot;休息一下, 吃根香蕉&quot;&gt;&lt;/a&gt;休息一下, 吃根香蕉&lt;/h2&gt;&lt;p&gt;hexo是个Node的程序, 那就意味着Node的辣么多包都是可以搞起的, 虽然我不会. 看起来hexo的架构设计得还不错, 没有仔细研究, 它大概是把事情分成了好几部, 处理文件, 渲染post, 生成各个页面等, 还有filter神马的没仔细看. 每个步骤都可以充分发挥你的想象去做事情, 只要符合规范就好. 而且它可以很好地发挥Node的异步特性, 让页面并行生成.&lt;/p&gt;
&lt;p&gt;目前我的模板是用的jade, css用的scss来写, post当然是markdown啦.&lt;/p&gt;
&lt;p&gt;我的侧边栏和原版的不一样哦, 不会滚出屏幕哦, 不会看到文章后边的时候觉得页面空空的, 也不是单纯的吸顶, 要考虑内容长过窗口高度的情况. 反正是费了点儿功夫, 代码很简单, 也已经把这个做成了一个可开关的功能.&lt;/p&gt;
&lt;p&gt;分享的那个小弹窗觉得原版做得不合理, 于是也改了一下, 布局方式改了, 并且把里面的项目做成了可配置. 其他还有不少改动主要是改进一下布局方式和删了不少代码.&lt;/p&gt;
&lt;h2 id=&quot;总之&quot;&gt;&lt;a href=&quot;#总之&quot; class=&quot;headerlink&quot; title=&quot;总之&quot;&gt;&lt;/a&gt;总之&lt;/h2&gt;&lt;p&gt;我觉得一定是我没有弄明白人家的牛逼之处, 还吐这么多槽, 笨死了🙁.&lt;/p&gt;
&lt;p&gt;其实不就是个静态博客系统么?! 可是折腾的天性加上Node让我很很看好hexo, 是不是&lt;strong&gt;github page&lt;/strong&gt;也支持一下hexo? 哈哈, 这样我就不用每次都要先generate再提交了. 大家也来用一下哇~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;思量再三, 还是不用jekyll了. Ruby什么的累觉不爱, 最关键的是我刚装上最新版就直接不能启动... &lt;/p&gt;
&lt;p&gt;什么? &lt;span style=&quot;color:rgb(179,62,170)&quot;&gt;&lt;strong&gt;没有给空定义match方法&lt;/strong&gt;&lt;/span&gt;. 喂, 还能再详细点儿么? 让我怎么排查问题?&lt;/p&gt;
&lt;p&gt;正好听朋友说&lt;strong&gt;hexo&lt;/strong&gt;, 去䁖了一眼, 用Node做的. 文档真的是...(省略吐槽无数). 擦擦嘴, 喝口水. 其实做得挺不错的, 除了默认主题有点儿丑外加文档很烂以外. &lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>swift AnyObject little tips</title>
    <link href="/2016/04/13/swift-AnyObject-little-tips/"/>
    <id>/2016/04/13/swift-AnyObject-little-tips/</id>
    <published>2016-04-13T02:44:37.000Z</published>
    <updated>2016-04-13T13:09:30.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;code&gt;AnyObject&lt;/code&gt;在swift里面比较特别. 它是所有类都隐式实现的一个&lt;code&gt;protocol&lt;/code&gt;. Apple的注释里面写着当被用作一个具体类型时, 
所有&lt;code&gt;@objc&lt;/code&gt;的方法和属性都被编译器认为可以访问, 并且都被标记为隐式解包类型. &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;The protocol to which all classes implicitly conform.&lt;/p&gt;
&lt;p&gt;When used as a concrete type, all known &lt;strong&gt;@objc&lt;/strong&gt; methods and
 properties are available, as implicitly-unwrapped-optional methods
 and properties respectively, on each instance of &lt;strong&gt;AnyObject&lt;/strong&gt;. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此, 在强类型中就混入了弱类型的不安定因素.&lt;/p&gt;
&lt;h2 id=&quot;Property&quot;&gt;&lt;a href=&quot;#Property&quot; class=&quot;headerlink&quot; title=&quot;Property&quot;&gt;&lt;/a&gt;Property&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; value: &lt;span class=&quot;hljs-type&quot;&gt;AnyObject&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;abc&quot;&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; frame = value.frame&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;value&lt;/code&gt;其实是&lt;code&gt;String&lt;/code&gt;类型, 这里声明为&lt;code&gt;AnyObject&lt;/code&gt;, 然后就可以尝试访问&lt;code&gt;frame&lt;/code&gt;这个&lt;code&gt;String&lt;/code&gt;没有的property. 然后&lt;code&gt;frame&lt;/code&gt;会是&lt;code&gt;CGRect!&lt;/code&gt;类型并且值为&lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果要链式访问, 安全的做法用&lt;strong&gt;?&lt;/strong&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; minX = value.frame?.minX  &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;CGFloat?&#39;&lt;/span&gt;

&lt;span class=&quot;hljs-comment&quot;&gt;// not safe&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; minX = value.frame.minX  &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;CGFloat!&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;method&quot;&gt;&lt;a href=&quot;#method&quot; class=&quot;headerlink&quot; title=&quot;method&quot;&gt;&lt;/a&gt;method&lt;/h2&gt;&lt;p&gt;方法和属性其实是一样的. 只不过可以被调用而已. 因此code也几乎一样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; result = value.stringByAppendingString?(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;)  &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;String?&#39;&lt;/span&gt;

&lt;span class=&quot;hljs-comment&quot;&gt;// not safe&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; result = value.stringByAppendingString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;test&quot;&lt;/span&gt;)  &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;String&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;处理JSON&quot;&gt;&lt;a href=&quot;#处理JSON&quot; class=&quot;headerlink&quot; title=&quot;处理JSON&quot;&gt;&lt;/a&gt;处理JSON&lt;/h2&gt;&lt;p&gt;经常我们从HTTP请求拿到的是JSON, 转换成&lt;code&gt;NSDictionary&lt;/code&gt;或者&lt;code&gt;NSArray&lt;/code&gt;再传递给应用逻辑. 现在假设我们要获取JSON里面的信息.&lt;/p&gt;
&lt;h3 id=&quot;使用-valueForKey&quot;&gt;&lt;a href=&quot;#使用-valueForKey&quot; class=&quot;headerlink&quot; title=&quot;使用 valueForKey&quot;&gt;&lt;/a&gt;使用 valueForKey&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; name = value.valueForKey?(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是, 如果value不是Dict, 或者value是Array但是里面的元素不是Object, 这样就有可能引发 &lt;code&gt;valueForUndefinedKey:&lt;/code&gt;, 抛出exception. 当然, &lt;code&gt;valueForKeyPath&lt;/code&gt;也是一样的. &lt;/p&gt;
&lt;h3 id=&quot;使用-objectForKey&quot;&gt;&lt;a href=&quot;#使用-objectForKey&quot; class=&quot;headerlink&quot; title=&quot;使用 objectForKey&quot;&gt;&lt;/a&gt;使用 objectForKey&lt;/h3&gt;&lt;p&gt;所以呀, 既然认为value是JSON中的Object, 为什么不用更加自然的&lt;code&gt;objectForKey&lt;/code&gt;呢? &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; name = value.objectForKey?(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样当value不是dict, 也就没有objectForKey这个方法, 也就不会crash了. 然后name仍然是Optional. 
这样的假定在处理JSON时时有效的, 因为JSON支持的数据类型中只有object才有这个方法, 其他的array, boolean, number, string和null都没有.&lt;/p&gt;
&lt;h3 id=&quot;使用-下标语法&quot;&gt;&lt;a href=&quot;#使用-下标语法&quot; class=&quot;headerlink&quot; title=&quot;使用 下标语法&quot;&gt;&lt;/a&gt;使用 下标语法&lt;/h3&gt;&lt;p&gt;对于用key来访问还有个偏僻的小路可以走一下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; name = value[&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// will be `AnyObject?!`&lt;/span&gt;

&lt;span class=&quot;hljs-comment&quot;&gt;// or do this tricky way&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; name = value[&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;]?.flatMap{$&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;} &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;AnyObject?&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里用&lt;code&gt;flatMap&lt;/code&gt;只是一种对两层&lt;code&gt;Optional&lt;/code&gt;剥壳的手段, 用 &lt;code&gt;xx ?? nil&lt;/code&gt; 也能剥壳. 剥壳虽然比较丑, 但是却不会引起崩溃.&lt;/p&gt;
&lt;p&gt;如果要继续深入keyPath的话......&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; content = value[&lt;span class=&quot;hljs-string&quot;&gt;&quot;person&quot;&lt;/span&gt;]?.flatMap({$&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;})?[&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;]?.flatMap({$&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;}) &lt;span class=&quot;hljs-comment&quot;&gt;// will be &#39;AnyObject?&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过我觉得最好还是用&lt;code&gt;objectForKey&lt;/code&gt;来从JSON获取信息, 并做好类型检查.&lt;/p&gt;
&lt;h2 id=&quot;总结-6&quot;&gt;&lt;a href=&quot;#总结-6&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;呵呵哒... 总结就是不要乱用, 少年, 除非你真的知道自己在做什么&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;AnyObject&lt;/code&gt;在swift里面比较特别. 它是所有类都隐式实现的一个&lt;code&gt;protocol&lt;/code&gt;. Apple的注释里面写着当被用作一个具体类型时, 
所有&lt;code&gt;@objc&lt;/code&gt;的方法和属性都被编译器认为可以访问, 并且都被标记为隐式解包类型. &lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="swift" scheme="/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>集成NativeScript iOSRuntime到已有工程</title>
    <link href="/2016/04/11/nativescript/"/>
    <id>/2016/04/11/nativescript/</id>
    <published>2016-04-11T04:50:49.000Z</published>
    <updated>2016-04-12T12:22:44.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://www.nativescript.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NativeScript&lt;/a&gt;是一个保加利亚公司&lt;strong&gt;Telerik&lt;/strong&gt;开发的, 其目标比较受争议: &lt;code&gt;write once, run everywhere&lt;/code&gt;. 它提供了Android, Windows Phone和iOS的JS Runtime, 以及一些周边比如css和html的解析, 一些wrap的模块来消除不同平台的差异. 但是我们只需要它提供的Runtime来用JS开发原生应用就好, 因为写起来还不错.&lt;/p&gt;
&lt;h2 id=&quot;iOS-Runtime&quot;&gt;&lt;a href=&quot;#iOS-Runtime&quot; class=&quot;headerlink&quot; title=&quot;iOS Runtime&quot;&gt;&lt;/a&gt;iOS Runtime&lt;/h2&gt;&lt;p&gt;关于NativeScript的介绍可以去Google一下, 很多人拿来和&lt;a href=&quot;https://facebook.github.io/react-native/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react-native&lt;/a&gt;比较, 一般对比比较多的是如何编写页面这一块. 当然这不是这篇文章的目的, 我只是比较在意NativeScript的Runtime, 它提供了js到原生的调用转换, 而且看起来挺不错. Android和Windows Phone没有研究过, 这里只聊聊iOS Runtime. 后文提到runtime如无特殊说明都是指iOS Runtime.
先看看code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; vc = UIView.alloc().init();
&lt;span class=&quot;hljs-comment&quot;&gt;// var vc = new UIViewController(); // same as last line&lt;/span&gt;

vc.view.backgroundColor = UIColor.redColor();

&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; nav = &lt;span class=&quot;hljs-comment&quot;&gt;/* some navigation controller */&lt;/span&gt;;

nav.pushViewControllerAnimated(vc, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);

&lt;span class=&quot;hljs-built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;hljs-string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来真的挺不错的. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建&lt;code&gt;UIViewController&lt;/code&gt; 可以用 &lt;code&gt;new&lt;/code&gt;关键字, 也可以使用方法调用的形式.&lt;/li&gt;
&lt;li&gt;直接使用&lt;strong&gt;property&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;调用多个参数的API时, 是把所有的参数label都拼到了一起, 所以&lt;code&gt;pushViewController:Animated:&lt;/code&gt;转换成了&lt;code&gt;pushViewControllerAnimated&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;打日志还是&lt;code&gt;console.log&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多特性和限制看官网doc. 现在还支持了JS6, 看官方说明也支持TypeScript, 而且在和Angular team合作, 可以支持Angular2的样子.&lt;/p&gt;
&lt;p&gt;对了, 这货开源, Github上还提了一嘴:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The iOS runtime is written in a fun mix of C++, Objective-C, and more&lt;/strong&gt;. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后还有一个&lt;strong&gt;NativeScript Member&lt;/strong&gt; PanayotCankov 对issue的&lt;a href=&quot;https://github.com/NativeScript/NativeScript/issues/1121&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;回复&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the long term you may consider the ios-runtime is doing with JavaScript something similar to what Swift is doing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;呵呵...&lt;/p&gt;
&lt;h2 id=&quot;集成到现有工程&quot;&gt;&lt;a href=&quot;#集成到现有工程&quot; class=&quot;headerlink&quot; title=&quot;集成到现有工程&quot;&gt;&lt;/a&gt;集成到现有工程&lt;/h2&gt;&lt;p&gt;关于如何完全用&lt;strong&gt;NativeScript&lt;/strong&gt;写应用, 可以去官网看教程. 我这里就只记录一下集成Runtime到已有工程的步骤. &lt;strong&gt;NativeScript&lt;/strong&gt;在创建一个新应用时会生成iOS工程目录.
里面有一个叫做&amp;#39;internal&amp;#39;的文件夹. 所有的东西都在里面了.&lt;/p&gt;
&lt;h4 id=&quot;配置Build-Phases&quot;&gt;&lt;a href=&quot;#配置Build-Phases&quot; class=&quot;headerlink&quot; title=&quot;配置Build Phases&quot;&gt;&lt;/a&gt;配置Build Phases&lt;/h4&gt;&lt;p&gt;Runtime需要添加3个&lt;code&gt;run script&lt;/code&gt;. 可以照着样例工程里面来copy, 只要路径正确即可. 3个&lt;code&gt;run script&lt;/code&gt;分别是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;nativescript-pre-build&lt;/code&gt; 添加在&lt;strong&gt;Target Dependencies&lt;/strong&gt;后面.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nativescript-pre-link&lt;/code&gt; 添加在&lt;strong&gt;Compile Sources&lt;/strong&gt;后面.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nativescript-post-build&lt;/code&gt; 添加在最后, 这个是为了清除掉模拟器相关的切片, 不然Apple会拒.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;配置Build-Settings&quot;&gt;&lt;a href=&quot;#配置Build-Settings&quot; class=&quot;headerlink&quot; title=&quot;配置Build Settings&quot;&gt;&lt;/a&gt;配置Build Settings&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;internal&lt;/strong&gt;里面好几个xcconfig, 其实很简单的, 只用到了一个&lt;code&gt;nativescript-build.xconfig&lt;/code&gt;, 至于是用xcconfig还是直接裸写在setting里面, 看自己的需求. 
文件里面配置了&lt;code&gt;HEADER_SEARCH_PATHS&lt;/code&gt;, &lt;code&gt;OTHER_LDFLAGS&lt;/code&gt;以及&lt;code&gt;FRAMEWORK_SEARCH_PATHS&lt;/code&gt;. 这些值里面有些是相对路径, 自己调整正确就好. &lt;/p&gt;
&lt;p&gt;默认配置的是用&lt;code&gt;.a&lt;/code&gt;, 如果要改成用framework, 先在&lt;code&gt;OTHER_LDFLAGS&lt;/code&gt;里面去掉对&lt;code&gt;.a&lt;/code&gt;的引用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;-lNativeScript -L$(SRCROOT)/internal/NativeScript/&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;lib&lt;/span&gt; //引用的是.&lt;span class=&quot;hljs-title&quot;&gt;a&lt;/span&gt;, 删掉这个&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后把&lt;code&gt;NativeScript.framework&lt;/code&gt;拖拽到自己应用的Target的&lt;strong&gt;Embedded Binaries&lt;/strong&gt;里面, 这个framework是iOS8以后支持的dynamic framework. 
还需要在这个framework的根目录下添加一个&lt;strong&gt;Modules&lt;/strong&gt;文件夹, 在文件夹里面创建module.modulemap文件, 其内容如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;framework &lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt; NativeScript {
  umbrella header &lt;span class=&quot;hljs-string&quot;&gt;&quot;NativeScript.h&quot;&lt;/span&gt;

  &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; *
  &lt;span class=&quot;hljs-keyword&quot;&gt;module&lt;/span&gt; * { &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; * }
}&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;修改程序入口&quot;&gt;&lt;a href=&quot;#修改程序入口&quot; class=&quot;headerlink&quot; title=&quot;修改程序入口&quot;&gt;&lt;/a&gt;修改程序入口&lt;/h4&gt;&lt;p&gt;看了一下样例工程, 扒出来这几行关键&lt;strong&gt;OC&lt;/strong&gt;代码. swift怎么弄不会, 所以是OC哦.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#import &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;NativeScript/NativeScript.h&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;// #import &quot;YourTarget-swift.h&quot; 如果用AppDelegate是swift类&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; startOfMetadataSection __&lt;span class=&quot;hljs-keyword&quot;&gt;asm&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;section$start$__DATA$__TNSMetadata&quot;&lt;/span&gt;);    &lt;span class=&quot;hljs-comment&quot;&gt;//抄过来的...&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;hljs-keyword&quot;&gt;char&lt;/span&gt; * argv[])
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;@autoreleasepool&lt;/span&gt; {
        [T&lt;span class=&quot;hljs-built_in&quot;&gt;NSRuntime&lt;/span&gt; initializeMetadata:&amp;amp;startOfMetadataSection];
        [T&lt;span class=&quot;hljs-built_in&quot;&gt;NSRuntimeInspector&lt;/span&gt; setLogsToSystemConsole:&lt;span class=&quot;hljs-literal&quot;&gt;YES&lt;/span&gt;];    &lt;span class=&quot;hljs-comment&quot;&gt;// 可以自己添加条件编译, 在release下扔掉&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;UIApplicationMain&lt;/span&gt;(argc, argv, &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([AppDelegate class]));
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果&lt;code&gt;APPDelegate&lt;/code&gt;是&lt;strong&gt;swift&lt;/strong&gt;写的, 需要添加&lt;strong&gt;Bridging Header&lt;/strong&gt;(避免build error), 并import一下swift到OC的转换头文件, 不是那个bridging header, 而是&lt;code&gt;YourTarget-swift.h&lt;/code&gt;那个文件. 详情查阅&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apple文档&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h4&gt;&lt;p&gt;如果没啥问题的话, 应该就能build过了. 接下来简单配置一下, 创建一个目录比如&lt;code&gt;JS&lt;/code&gt;, 以文件夹引用的方式引入, 并将其设置为copy到mainBundle. 文件夹内添加一个&lt;code&gt;app.js&lt;/code&gt;文件, 随便写点儿log神马的.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; runtime = &lt;span class=&quot;hljs-type&quot;&gt;TNSRuntime&lt;/span&gt;(applicationPath: appPath)    &lt;span class=&quot;hljs-comment&quot;&gt;// 指向文件夹&lt;/span&gt;
runtime.scheduleInRunLoop(&lt;span class=&quot;hljs-type&quot;&gt;NSRunLoop&lt;/span&gt;.mainRunLoop(), forMode: &lt;span class=&quot;hljs-type&quot;&gt;NSRunLoopCommonModes&lt;/span&gt;)

runtime.executeModule(&lt;span class=&quot;hljs-string&quot;&gt;&quot;./&quot;&lt;/span&gt;)     &lt;span class=&quot;hljs-comment&quot;&gt;// 执行app.js&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;&gt;&lt;/a&gt;存在的问题&lt;/h2&gt;&lt;p&gt;目前也只是刚扒出来, 网上的资料比较少, 对&lt;strong&gt;JavaScriptCore&lt;/strong&gt;也不是很了解, 弄起来比较费劲. 目前存在一些问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;TNSRuntime&lt;/code&gt;对象有个&lt;code&gt;globalContext&lt;/code&gt;方法返回&lt;code&gt;JSGlobalContextRef&lt;/code&gt;, 但是拿去创建&lt;code&gt;JSContext&lt;/code&gt;就会崩溃, 报&lt;strong&gt;WTFCrash&lt;/strong&gt;... 不过直接用C的API去执行JS貌似没事. 只要想要retain, 或者copyName都会导致crash. 不知道原因.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每次build都要消耗一定时间去generate metadata. SSD大概十几秒的样子?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供了一大堆module, 用得上的没几个. 代码是直接复制到app bundle, 等于开源了, 当然处理一下也是可以的.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;p&gt;其实研究一下它主要是看中它JS编写原生页面的能力, coding起来跟写OC或者swift很像, 而且可以完全不理会它提供的包, 依然用自己熟悉的方式开发. 学习成本几乎为0啊. 感觉如果认真研究一下, 配置成远端下载脚本到本地执行应该是没有问题(可能有不少坑). 这样热更新应用, 甚至去掉h5, 改用NativeScript来提供页面都可以尝试, 原生效果肯定比h5好啊.&lt;/p&gt;
&lt;p&gt;还有它遵循&lt;strong&gt;CommonJS&lt;/strong&gt;, 可以打包一些js的库来用, 挺方便的. &lt;/p&gt;
&lt;p&gt;最重要的一点最后说: 它是在编译的时候调用generate metadata去生成API的映射, 在执行js之前会load几个常用模块比如UIKit, Foundation, 然后有些模块会在第一次调用的时候load. 如果iOS更新了, 你不需要更新NativeScript, 即可立即开始使用新API, 因为你编译的时候新的API就会被检索, 被放到metadata里面. &lt;/p&gt;
&lt;p&gt;其他的比如&lt;strong&gt;Xamarin&lt;/strong&gt;就必须等SDK更新才能有机会调用新的API, 而&lt;strong&gt;React-Native&lt;/strong&gt; 目前只能通过写模块来和native通信, 不具备直接调用的能力.&lt;/p&gt;
&lt;p&gt;如果再有其他进展, 再继续更新本文.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.nativescript.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NativeScript&lt;/a&gt;是一个保加利亚公司&lt;strong&gt;Telerik&lt;/strong&gt;开发的, 其目标比较受争议: &lt;c
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="NativeScript" scheme="/tags/NativeScript/"/>
    
  </entry>
  
  <entry>
    <title>swift 2.2 类型转换小坑</title>
    <link href="/2016/03/28/swift_type_convert/"/>
    <id>/2016/03/28/swift_type_convert/</id>
    <published>2016-03-28T06:00:00.000Z</published>
    <updated>2016-04-17T03:36:09.000Z</updated>
    
    <content type="html">&lt;p&gt;XCode升级到了7.3, swift到了2.2. 之前发现的坑在这里验证了一下, 依然没啥变化. 特此记录一下.&lt;/p&gt;
&lt;p&gt;本文主要填一下类型转换的坑, 包括 &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;Optional&lt;/code&gt;, &lt;code&gt;函数参数&lt;/code&gt;,&lt;code&gt;闭包&lt;/code&gt; 以及&lt;code&gt;Tuple&lt;/code&gt;. 总之, &lt;code&gt;class&lt;/code&gt;和&lt;code&gt;非class&lt;/code&gt;的待遇是不一样的, Any和AnyObject的区别也是很重要的.
&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;主要是针对Array类型, 其他&lt;code&gt;CollectionType&lt;/code&gt;也类似.&lt;/p&gt;
&lt;p&gt;本文代码中的通用定义:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt; &lt;/span&gt;{}    &lt;span class=&quot;hljs-comment&quot;&gt;//swift protocol without @objc&lt;/span&gt;

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;{}
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;B&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;{}

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;AP&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt; &lt;/span&gt;{}
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BP&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;AP&lt;/span&gt; &lt;/span&gt;{}

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;S&lt;/span&gt; &lt;/span&gt;{}
&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SP&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;P&lt;/span&gt; &lt;/span&gt;{}

&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; arrayA = [&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()], arrayB = [&lt;span class=&quot;hljs-type&quot;&gt;B&lt;/span&gt;()], arrayS = [&lt;span class=&quot;hljs-type&quot;&gt;S&lt;/span&gt;()], arrayPA: [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;] = [&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()], arrayPS: [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;] = [&lt;span class=&quot;hljs-type&quot;&gt;S&lt;/span&gt;()]&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;as-is-以及-Optional&quot;&gt;&lt;a href=&quot;#as-is-以及-Optional&quot; class=&quot;headerlink&quot; title=&quot;as is, = 以及 Optional&quot;&gt;&lt;/a&gt;as is, = 以及 Optional&lt;/h2&gt;&lt;p&gt;三者的坑类似, 主要是array类型的推断. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;as&lt;/code&gt;操作符将一个类型转换成平级类型或者父类型, 例如 &lt;code&gt;&amp;quot;abc&amp;quot; as NSString&lt;/code&gt;可以看成是平级转换, &lt;code&gt;b as A&lt;/code&gt; 是转换到父类型.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as!&lt;/code&gt;和&lt;code&gt;as?&lt;/code&gt;是用于将父类型变量转换为子类型.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is&lt;/code&gt;是check父类型变量是否为子类型.&lt;/li&gt;
&lt;li&gt;某种程度上, &lt;code&gt;Optional&lt;/code&gt;可以看做是其&lt;code&gt;T&lt;/code&gt;的父类型.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;普通类型进行各种转换检查都没什么问题, 但是当普通类型碰上&lt;strong&gt;集合&lt;/strong&gt;呢? &lt;/p&gt;
&lt;p&gt;先看code:&lt;/p&gt;
&lt;p&gt;as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;arrayA &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;]  &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;
arrayA &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;]    &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;
arrayA &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;AnyObject&lt;/span&gt;]    &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;
arrayB &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;]            &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;

arrayS &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;]    &lt;span class=&quot;hljs-comment&quot;&gt;// compiler, Cannot convert value of type &#39;[C]&#39; to type &#39;[P]&#39; in coercion&lt;/span&gt;
arrayS &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;]    &lt;span class=&quot;hljs-comment&quot;&gt;// compiler, Cannot convert value of type &#39;[C]&#39; to type &#39;[Any]&#39; in coercion&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;arrayPA &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;
arrayPS &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;S&lt;/span&gt;] &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: can&#39;t unsafeBitCast between types of different sizes&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;赋值:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; a: [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;] = arrayA &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; a: [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;] = arrayA &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; a: [&lt;span class=&quot;hljs-type&quot;&gt;AnyObject&lt;/span&gt;] = arrayA &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; s: [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;] = arrayS &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; s: [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;] = arrayS &lt;span class=&quot;hljs-comment&quot;&gt;// runtime, fatal error: array cannot be bridged from Objective-C&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大概是因为OC的runtime吧. 可不是么? 文档有提到&lt;code&gt;@objc&lt;/code&gt; 将指定的方法或者属性暴露给OC, 而&lt;code&gt;AnyObject&lt;/code&gt;是带有这个标记的, 因此在类型检查和转换时行为跟&lt;code&gt;NSArray&lt;/code&gt;差不多. &lt;code&gt;Any&lt;/code&gt;没有&lt;code&gt;@objc&lt;/code&gt;. &lt;code&gt;protocol&lt;/code&gt; 不带&lt;code&gt;@objc&lt;/code&gt;时和&lt;code&gt;Any&lt;/code&gt;一样, 带上了&lt;code&gt;@objc&lt;/code&gt;就和&lt;code&gt;AnyObject&lt;/code&gt;一样. &lt;code&gt;Optional&lt;/code&gt;也是swift特有, 因此行为上和Any类似.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;arrayA &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;NSArray&lt;/span&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;
arrayS &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;NSArray&lt;/span&gt;     &lt;span class=&quot;hljs-comment&quot;&gt;// // compiler, Cannot convert value of type &#39;[S]&#39; to type &#39;NSArray&#39; in coercion&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只要不牵扯到swift特有的东西(struct, 不带@objc的protocol, Optional), 大部分的转换都可以看成是到NSArray的转换, 当然swift也有类型检查, 不能乱转. &lt;/p&gt;
&lt;p&gt;然而事情总有意外...&lt;/p&gt;
&lt;p&gt;真的只能这样了么? 不是的. 字面量数组可以躲过一些劫难. 因为类型推断的缘故. 继续看code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;[&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()] &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;]
[&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()] &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;]
[&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()] &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;AnyObject&lt;/span&gt;]

[&lt;span class=&quot;hljs-type&quot;&gt;S&lt;/span&gt;()] &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;]
[&lt;span class=&quot;hljs-type&quot;&gt;S&lt;/span&gt;()] &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; [&lt;span class=&quot;hljs-type&quot;&gt;Any&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类型推断至上而下, 表达式的类型最终为[P], 倒推左值需要为[P], 此时左值只知道是Array, 未推断T, 进而继续推断其Generator.Element需要为P. 而A可以转换为P, 所以字面量数组创建出来就是[P]类型而不存在转换. 这是编译器做的.&lt;/p&gt;
&lt;p&gt;赋值的操作类似, 只要把右值换成对应的字面量数组就可以成功赋值, 而&lt;code&gt;is&lt;/code&gt;操作因为类型推断, 字面量数组最终的类型就是右值, 没有意义. &lt;/p&gt;
&lt;p&gt;哦, 类型推断哪...&lt;/p&gt;
&lt;h2 id=&quot;函数参数-和-闭包&quot;&gt;&lt;a href=&quot;#函数参数-和-闭包&quot; class=&quot;headerlink&quot; title=&quot;函数参数 和 闭包&quot;&gt;&lt;/a&gt;函数参数 和 闭包&lt;/h2&gt;&lt;p&gt;函数有入参和返回值, 调用函数时传递参数也是一个赋值的过程, 因此可以参考上文的现象. 也就是说传递进来的参数要能正确转换成函数需要的类型, 函数内部的返回值也要能正确转换为声明的类型. 只要符合这些条件, 调用就没有问题.&lt;/p&gt;
&lt;p&gt;那么问题来了, 闭包也是函数, 闭包的类型如何转换?&lt;/p&gt;
&lt;p&gt;又来一份code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f: A -&amp;gt; P)&lt;/span&gt;&lt;/span&gt; {}
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(p: P)&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt; {}

test(param)    &lt;span class=&quot;hljs-comment&quot;&gt;// OK&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原理并不难, 先看闭包的入参, 需求为A类型, 也就意味着在&lt;code&gt;test&lt;/code&gt;方法内部会传递一个变量给&lt;code&gt;f&lt;/code&gt;, 这个变量会在传递给&lt;code&gt;f&lt;/code&gt;时转换为&lt;code&gt;A&lt;/code&gt;类型. 也就是说&lt;code&gt;f&lt;/code&gt;应该能够处理&lt;code&gt;A&lt;/code&gt;类型的入参.因此, 如果我们传递的闭包的入参是&lt;code&gt;A&lt;/code&gt;的父类型&lt;code&gt;P&lt;/code&gt;, 它也能处理类型为&lt;code&gt;A&lt;/code&gt;的参数, 而如果是子类型&lt;code&gt;B&lt;/code&gt;则可能出错. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;一定是&lt;code&gt;P&lt;/code&gt;但不一定是&lt;code&gt;B&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;同样, 对于返回值, &lt;code&gt;test&lt;/code&gt;方法要返回&lt;code&gt;P&lt;/code&gt;类型, 因此我们可以返回&lt;code&gt;P&lt;/code&gt;类型的子类型&lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;前文提到, 某种程度上可以将&lt;code&gt;Optional&lt;/code&gt;看做是其&lt;code&gt;T&lt;/code&gt;的父类型, 因为编码过程中发现它在类型转换上的结果和父类型子类型的一致.因此下面的code也不需要特别处理:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testNil&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;? {
    &lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a         &lt;span class=&quot;hljs-comment&quot;&gt;// 编译器自动wrap&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Tuple&quot;&gt;&lt;a href=&quot;#Tuple&quot; class=&quot;headerlink&quot; title=&quot;Tuple&quot;&gt;&lt;/a&gt;Tuple&lt;/h2&gt;&lt;p&gt;Tuple没有什么特别的, 就是类型转换的时候不管类型继承, 当然, 字面量方式除外. 看起来就像是字符串比较:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; value = (&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;(), &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;()) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;P&lt;/span&gt;)    &lt;span class=&quot;hljs-comment&quot;&gt;// value 是 (P, P)类型&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; value &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; (&lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;hljs-type&quot;&gt;A&lt;/span&gt;) {

} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;hljs-comment&quot;&gt;// will got here&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;总结-5&quot;&gt;&lt;a href=&quot;#总结-5&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;写的时候尽量注意吧, 不要以为build过了就没事, 一些转换的坑在runtime等你呢(看上边的报错的注释吧). 拿不准就主动做个map吧.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;XCode升级到了7.3, swift到了2.2. 之前发现的坑在这里验证了一下, 依然没啥变化. 特此记录一下.&lt;/p&gt;
&lt;p&gt;本文主要填一下类型转换的坑, 包括 &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;, &lt;cod
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="swift" scheme="/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>2016 年后小总结</title>
    <link href="/2016/03/15/%E5%B9%B4%E5%90%8E%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>/2016/03/15/年后小总结/</id>
    <published>2016-03-15T07:00:00.000Z</published>
    <updated>2016-04-05T13:05:40.000Z</updated>
    
    <content type="html">&lt;p&gt;kaizei的2015小总结. 总算也是写了总结了...&lt;/p&gt;
&lt;p&gt;问: 不应该年前写总结么?&lt;/p&gt;
&lt;p&gt;答: 是的, 但是... hehe
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每个人都有自己可以填在但是后面的话, 我的是什么? 不告诉你.&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;p&gt;过完年了, 嗯, 不用提醒我已经过了1个多月了. 去年一年很颠簸, 跳了两次槽, 2月份离开人人去了tango, 然后8月份离开tango来到了现在的公司--财说. &lt;/p&gt;
&lt;p&gt;技术上还是那样, iOS为主, 公司使用swift开发, 经历了1到2的迁移, 我们的代码质量蛮高, 结构也比较合理, 很少的时间就完成了. 年底用swift开发了几个库, &lt;a href=&quot;https://github.com/kaizeiyimi/XLYAnimatedImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;动图播放&lt;/a&gt;, &lt;a href=&quot;https://github.com/kaizeiyimi/XAutoLayout&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XAutoLayout&lt;/a&gt;,  &lt;a href=&quot;https://github.com/kaizeiyimi/XLYTextKitExtension&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;扩展TextKit&lt;/a&gt;, &lt;a href=&quot;https://github.com/kaizeiyimi/Phantom&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Phantom&lt;/a&gt;, 前两个的质量高一些, 后面两个更像是试验品. 吐槽一句: 用swift开发和只是站在旁边学习是完全不一样的. 😛&lt;/p&gt;
&lt;p&gt; 有空倒腾了一下web技术, 感觉web技术才是未来的霸主. 断断续续看了一些js的书籍, 也倒腾了一些工具, &lt;code&gt;gulp&lt;/code&gt;, &lt;code&gt;browser-sync&lt;/code&gt;之类的, 还挺有意思的.&lt;/p&gt;
&lt;p&gt;生活上有点儿悲催. 工作性质加上我一般比较投入, 久坐较多, 人胖了, 气色差了, 头发少了, 脾气也没以前好了, 总之整个人都不好了. 搬家也搬了两次, 租房住的悲哀. 现在又回到了最开始的地荒--立水桥. 立水桥还是那个立水桥, 但是房租已经不是那个价位的房租了. 卖方市场下的我们也只能挣扎却无法摆脱年年涨租的问题.&lt;/p&gt;
&lt;p&gt;今年要多多锻炼身体, 多看点儿文学书籍. 篮球已经瘪了, 要打气了. 吉他上的灰很多, 要擦一下了. &lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color:rgb(179,62,170)&quot;&gt;darling&lt;/span&gt;说, 身上的肉肥了, 再不锻炼就该割了!&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;kaizei的2015小总结. 总算也是写了总结了...&lt;/p&gt;
&lt;p&gt;问: 不应该年前写总结么?&lt;/p&gt;
&lt;p&gt;答: 是的, 但是... hehe
    
    </summary>
    
      <category term="日常" scheme="/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="年终总结" scheme="/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>XLYAutoLayoutEasy</title>
    <link href="/2014/12/08/XLYAutoLayoutEasy/"/>
    <id>/2014/12/08/XLYAutoLayoutEasy/</id>
    <published>2014-12-08T08:00:00.000Z</published>
    <updated>2016-05-20T15:29:40.000Z</updated>
    
    <content type="html">&lt;p&gt;开发AutoLayoutEasy的目的是为了让代码编写AutoLayout更加方便直观, 提高可读性和可维护性. 因为我个人觉得iOS提供的创建约束的方式真心不敢恭维, NSLayoutConstraint的类方法写起来好长, VFL又不好操作具体约束, 写出来的代码可读性也不是很高.&lt;/p&gt;
&lt;h2 id=&quot;如何创建一个约束&quot;&gt;&lt;a href=&quot;#如何创建一个约束&quot; class=&quot;headerlink&quot; title=&quot;如何创建一个约束&quot;&gt;&lt;/a&gt;如何创建一个约束&lt;/h2&gt;&lt;p&gt;苹果在NSLayoutConstraint中提供了一个类方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;+(instancetype)constraintWithItem:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)view1 
                        attribute:(&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutAttribute&lt;/span&gt;)attr1 
                        relatedBy:(&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutRelation&lt;/span&gt;)relation
                           toItem:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)view2 
                        attribute:(&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutAttribute&lt;/span&gt;)attr2 
                       multiplier:(&lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat&lt;/span&gt;)multiplier 
                         constant:(&lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat&lt;/span&gt;)c;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用于创建两个item之间的约束, 一次只能描述某两个属性的关系. 比如需要view1的left和view2的right保持10的偏移量. 那么这里的调用就是这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutConstraint&lt;/span&gt; constraintWithItem:view1 
                             attribute:&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutAttributeLeft&lt;/span&gt;
                             relatedBy:&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutRelationEqual&lt;/span&gt;
                                toItem:view2
                             attribute:&lt;span class=&quot;hljs-built_in&quot;&gt;NSLayoutAttributeRight&lt;/span&gt;
                            multiplier:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
                              constant:&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好长有木有, 但是很清晰, 至少明确地表达了两个view的两个属性间的关系. VFL的描写方式就不写了. 这里获取到了一个constraint对象, 下一步我需要让它生效, 我需要找到一个view去调用&lt;code&gt;[view addConstraint:constraint]&lt;/code&gt;, 这个view必须是view1和view2的一个公共父view. 完成操作后, 等到下一个刷新周期约束就会生效了.&lt;/p&gt;
&lt;h2 id=&quot;XLYAutoLayoutEasy&quot;&gt;&lt;a href=&quot;#XLYAutoLayoutEasy&quot; class=&quot;headerlink&quot; title=&quot;XLYAutoLayoutEasy&quot;&gt;&lt;/a&gt;XLYAutoLayoutEasy&lt;/h2&gt;&lt;p&gt;虽然创建约束的方法很直观, 但是我仍然认为它太复杂, 太长了. 屏幕杀手. 先看一眼我的lib如何描写一个约束.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;  view1.layoutLeft.equalTo(view2.layoutRight).constant(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;怎么看都更加简单. &lt;strong&gt;简化约束的创建是XLYAutoLayoutEasy的核心&lt;/strong&gt;, 所有的约束创建都使用类似的方法. 如果firstItem和secondItem使用相同的layout属性, 可以不用书写secondItem的layout属性. 如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;//view1的宽度等于view2的宽度乘1再加上10&lt;/span&gt;
  view1.layoutWidth.equalTo(view2).constant(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是根superView的对应属性做约束, 甚至可以写成这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;//等同view1.layoutLeading.equalTo(superView.layoutLeading).constant(100);&lt;/span&gt;
  view1.layoutLeading.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的单行代码创建的是XLYConstraint对象, 需要调用resultConstraint来获取NSLayoutConstraint对象.&lt;/p&gt;
&lt;p&gt;XLYAutoLayoutEasy还顺带提供了一些helper方法, 辅助激活, 更新和重建约束. &lt;/p&gt;
&lt;h4 id=&quot;批量创建约束&quot;&gt;&lt;a href=&quot;#批量创建约束&quot; class=&quot;headerlink&quot; title=&quot;批量创建约束&quot;&gt;&lt;/a&gt;批量创建约束&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; makeConstraints:^{
  testView.layoutTop.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.topLayoutGuideView.layoutBottom).constant(&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;);
  testView.layoutTrailing.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.view).constant(&lt;span class=&quot;hljs-number&quot;&gt;-50&lt;/span&gt;);
  testView.layoutLeading.equalToConstant(&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;);
  testView.layoutHeight.equalToConstant(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
}];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用makeConstraint的方法会自动将block里面创建的约束激活, 无需再自行寻找公共父view进行添加.&lt;/p&gt;
&lt;h4 id=&quot;更新约束&quot;&gt;&lt;a href=&quot;#更新约束&quot; class=&quot;headerlink&quot; title=&quot;更新约束&quot;&gt;&lt;/a&gt;更新约束&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; updateConstraints:^{
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutLeading.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.view).constant(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutHeight.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;);
}];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有在updateConstraints里面创建的约束会首先查找有没有一个约束和创建出来的约束相似(后文会解释相似的判定), 如果有, 则修改constant, 否则添加新创建的约束. 
如果使用iOS的方法, 则需要记录下之前创建的约束来修改constant. &lt;/p&gt;
&lt;h4 id=&quot;重建约束&quot;&gt;&lt;a href=&quot;#重建约束&quot; class=&quot;headerlink&quot; title=&quot;重建约束&quot;&gt;&lt;/a&gt;重建约束&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; remakeConstraints:^{  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutBottom.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.bottomLayoutGuideView.layoutTop).constant(&lt;span class=&quot;hljs-number&quot;&gt;-100&lt;/span&gt;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutWidth.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutHeight.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
    &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutLeading.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.view.layoutLeading);
}];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法会记录所有在remakeConstraints中出现的作为firstItem的view, 并把跟这些view相关的所有约束去掉(不包含hugging, compression resistance 的约束), 然后重新激活新创建的约束.&lt;/p&gt;
&lt;h2 id=&quot;灵感&quot;&gt;&lt;a href=&quot;#灵感&quot; class=&quot;headerlink&quot; title=&quot;灵感&quot;&gt;&lt;/a&gt;灵感&lt;/h2&gt;&lt;p&gt;大前提是&lt;code&gt;translatesAutoresizingMaskIntoConstraints = NO&lt;/code&gt;. 否则无法玩耍了. 既然使用了autoLayout就不要再搭着AutoResizingMask了.&lt;/p&gt;
&lt;p&gt;简单描述一下XLYAutoLayoutEasy的设计灵感来源. 在storyboard中编辑一个约束时, 我发现xcode标注了firstItem, relation, secondItem, constant, priority, multiplier. 其中firstItem和secondItem显示的是view.width这样的形式, 整个约束看起来十分清晰. 于是想到如果能在代码里面用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;view1&lt;span class=&quot;hljs-selector-class&quot;&gt;.width&lt;/span&gt; equalTo view2&lt;span class=&quot;hljs-selector-class&quot;&gt;.width&lt;/span&gt;, constant &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;, priority &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;, multiplier &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样的形式描述那多好.一下就看明白了. 于是想到给UIView添加分类, 提供类似width, height, leading这样的property. 为了准确表达是布局的属性, 在前面添加了layout, 于是就成了layoutWidth, layoutHeight, layoutLeading. 没有添加xly_的前缀是为了书写方便.
 首先定义了最基础的API:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;view.layoutWidth.equalTo(view2.layoutWidth);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关系有等于, 大于等于, 小于等于. constant, priority以及multiplier都有默认值, 分别是0, 1000, 1. 如果需要修改的话, 就在上面的表达式后面继续书写:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;view.layoutWidth.equalTo(view2.layoutWidth).constant(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;).priority(&lt;span class=&quot;hljs-number&quot;&gt;750&lt;/span&gt;).multiplier(&lt;span class=&quot;hljs-number&quot;&gt;1.5&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这三个属性书写的顺序可以随意交换.但是一定是在关系之后.&lt;/p&gt;
&lt;p&gt;这样的形式更像c或者swift的语法, OC里面怎么做呢? 用block. block在调用时是block()的形式. 只要返回值可以使用&lt;code&gt;.&lt;/code&gt; 进行调用的话这样的书写就没有问题. 因此就诞生了如下的方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;    - (XLYConstraint *(^)(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; attr))equalTo;
    - (XLYConstraint *(^)(&lt;span class=&quot;hljs-built_in&quot;&gt;CGFloat&lt;/span&gt; constant))constant;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用block作为返回值, 然后用()进行调用, 得到XLYConstraint的对象, 然后重复. 这样就能写出上面所展示的那种代码了. 我觉得这里如果用&lt;code&gt;[]&lt;/code&gt; 进行方法调用的话, 可读性会比较差, 所以...&lt;/p&gt;
&lt;p&gt;&lt;code&gt;view.layoutXXX&lt;/code&gt;这样的属性是XLYViewAttribute类型, 调用equalTo等描述关系的方法后才产生XLYConstraint对象, 这样做一方面是为了从概念上区分出约束的item和其他参数, 另一方面也方便了代码的分布.&lt;/p&gt;
&lt;p&gt;通过这样的调用最终生成的XLYConstraint对象记录了一个约束所需要的8个参数. 然后调用其&lt;code&gt;resultConstraint&lt;/code&gt;方法将生成所对应的NSLayoutConstraint对象.&lt;/p&gt;
&lt;h2 id=&quot;helper方法&quot;&gt;&lt;a href=&quot;#helper方法&quot; class=&quot;headerlink&quot; title=&quot;helper方法&quot;&gt;&lt;/a&gt;helper方法&lt;/h2&gt;&lt;p&gt;一个约束被创建后需要激活. ios7及以下系统需要自己寻找公共父view并添加, 因此我需要一个寻找两个view公共父view的方法. ios8及以上系统只需要设置active为YES即可.
在更新约束时, 我需要寻找到和当前约束&amp;#39;类似&amp;#39;的约束. 
在重建约束时, 我需要找到跟一个view相关联的所有约束.&lt;/p&gt;
&lt;p&gt;以上就是make, update和remake所依赖的核心方法.&lt;/p&gt;
&lt;h4 id=&quot;激活约束&quot;&gt;&lt;a href=&quot;#激活约束&quot; class=&quot;headerlink&quot; title=&quot;激活约束&quot;&gt;&lt;/a&gt;激活约束&lt;/h4&gt;&lt;p&gt;给NSLayoutConstraint添加了一个分类, 提供了xly_install 和 xly_uninstall方法来进行激活和移除操作, 方法中根据系统版本进行区别调用. 如果是ios8及以上只需设置active属性, ios7及以下则需要寻找最低公共父view来进行添加.&lt;/p&gt;
&lt;h4 id=&quot;更新约束-1&quot;&gt;&lt;a href=&quot;#更新约束-1&quot; class=&quot;headerlink&quot; title=&quot;更新约束&quot;&gt;&lt;/a&gt;更新约束&lt;/h4&gt;&lt;p&gt;更新约束时, 首先是创建了在block里面书写的约束, 然后去寻找是否有一个相似的约束, 如果没有的话就直接激活约束, 如果有就替换constant的值.&lt;/p&gt;
&lt;p&gt;什么是相似? 从NSLayoutConstraint中能看出来, 创建完一个约束后能修改的值只有priority和constant, priority还不建议在约束激活后再修改. 虽然经过测试发现只要优先级不是1000, 并且改动后的值也不是1000就没有问题, 否则崩溃. 这里尊重苹果的文档, 把优先级不同的约束当成不同的约束. 因此,相似的概念就是除了constant以外, 其他的值是&lt;strong&gt;逻辑相等&lt;/strong&gt;的. 为什么不是完全相等? 因为约束并不是单向的, 它是一个双向的限制, 约束的公式如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;view1.attr1 = view2.attr2 * multiplier + &lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个计算规则等同于下面这一个:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;null hljs&quot;&gt;view2.attr2 = view1.attr1 * ( &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/multiplier) - &lt;span class=&quot;hljs-built_in&quot;&gt;constant&lt;/span&gt;/multiplier&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此, 在寻找相似的约束时必须考虑第二种形式. 我定义相似的结果为3种, 相似, 逆向相似以及不相似. 查找时还得小心一种很特别的约束, 是通过设置view的hugging和compression resistance生成的. 这种约束的类是&lt;code&gt;NSContentSizeLayoutConstraint&lt;/code&gt;, 需要过滤掉. 最后一个细节就是相似的约束可能不止一个, 这种情况下多半是代码有问题, 约束加多了, 但是不管怎么着, 我只取最新的一个, 即最后添加的那个, 因此我会倒序遍历constraints数组来进行查找.&lt;/p&gt;
&lt;h4 id=&quot;重建约束-1&quot;&gt;&lt;a href=&quot;#重建约束-1&quot; class=&quot;headerlink&quot; title=&quot;重建约束&quot;&gt;&lt;/a&gt;重建约束&lt;/h4&gt;&lt;p&gt;重建, 就得先毁灭再重生. 应该被毁灭的是哪些呢? 我善做主张, 将所有关联的约束全部干掉. 比如代码这么写:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;[&lt;span class=&quot;hljs-built_in&quot;&gt;UIView&lt;/span&gt; remakeConstraints:^{  
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutBottom.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.bottomLayoutGuideView.layoutTop).constant(&lt;span class=&quot;hljs-number&quot;&gt;-100&lt;/span&gt;);
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutWidth.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutHeight.equalTo(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.testView.layoutLeading.equalTo(&lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.view.layoutLeading);
  &lt;span class=&quot;hljs-comment&quot;&gt;//这里不再多写了, view2也进行重建&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;self&lt;/span&gt;.view2 ...
}];&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;block里创建了多个约束, 作为firstItem出现的是testView和view2, 因此所有和testView和view2有关联的约束全部干掉. 约束是双向的, 有关联就是约束的firstItem或者secondItem等于这个view. 在寻找关联的约束时只能从自己开始, 逐步往window遍历所有的约束, 将关联的约束记下. 这里本来想利用runtime去替换addConstant和setActive方法, 在方法中进行记录的, 但是发现了iOS的一些诡异得无法解释的现象, 放弃了这条路, 只能每次遍历查找了, 效率相对低点儿. 这里同样要去掉&lt;code&gt;NSContentSizeLayoutConstraint&lt;/code&gt;类型的约束.&lt;/p&gt;
&lt;h2 id=&quot;兼顾swift&quot;&gt;&lt;a href=&quot;#兼顾swift&quot; class=&quot;headerlink&quot; title=&quot;兼顾swift&quot;&gt;&lt;/a&gt;兼顾swift&lt;/h2&gt;&lt;p&gt;以上的代码如果bridge到swift使用将显得很funny. 因为方法返回的是一个闭包, OC直接使用()就可以跟在后面继续调用, 但是swift会变成这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;swift hljs&quot;&gt;  view1.layoutLeft.equalTo()(view2.layoutRight).constant()(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此, 我专门为swift添加了两个头文件, 使得swift里面也能跟OC的写法一样.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;objc hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//其中一个, 另一个见代码&lt;/span&gt;
- (XLYConstraint *)equalTo:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)attr;
- (XLYConstraint *)greaterThanOrEqualTo:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)attr;
- (XLYConstraint *)lessThanOrEqualTo:(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)attr;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也专门弄了一个给swift bridge header用的&lt;code&gt;XLYAutoLayoutEasy-swift.h&lt;/code&gt;以区分import的头文件.&lt;/p&gt;
&lt;h2 id=&quot;总结-3&quot;&gt;&lt;a href=&quot;#总结-3&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;用helper方法配合简化约束的写法, 就能用较短的代码量写出我认为更加清晰可读的布局代码. 更新重建的操作也能更加容易. &lt;/p&gt;
&lt;p&gt;写代码, 多思考, 想清楚了需要什么再写. 多画图有助于思考.&lt;/p&gt;
&lt;p&gt;另外, 感谢我的她对我的包容和支持.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;开发AutoLayoutEasy的目的是为了让代码编写AutoLayout更加方便直观, 提高可读性和可维护性. 因为我个人觉得iOS提供的创建约束的方式真心不敢恭维, NSLayoutConstraint的类方法写起来好长, VFL又不好操作具体约束, 写出来的代码可读性
    
    </summary>
    
      <category term="技术" scheme="/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="/tags/iOS/"/>
    
      <category term="Github" scheme="/tags/Github/"/>
    
  </entry>
  
</feed>
