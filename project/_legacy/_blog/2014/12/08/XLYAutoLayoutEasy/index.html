<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="kaizeiの日常"><title>XLYAutoLayoutEasy | kaizeiとyimi</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/blog/css/highlight.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="shortcut icon" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/blog/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">XLYAutoLayoutEasy</h1><a id="logo" href="/blog/.">kaizeiとyimi</a><p class="description">kaizeiの日常</p></div><div id="nav-menu"><a href="/blog/." class="current"><i class="fa fa-home"> </i><span>首页</span></a><a href="/blog/archives/"><i class="fa fa-archive"> </i><span>归档</span></a><a href="/blog/about/"><i class="fa fa-user"> </i><span>关于</span></a><a href="/blog/atom.xml"><i class="fa fa-rss"> </i><span>订阅</span></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">XLYAutoLayoutEasy</h1><div class="post-meta">Dec 8, 2014<span> | </span><span class="category"><a href="/blog/categories/技术/">技术</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>开发AutoLayoutEasy的目的是为了让代码编写AutoLayout更加方便直观, 提高可读性和可维护性. 因为我个人觉得iOS提供的创建约束的方式真心不敢恭维, NSLayoutConstraint的类方法写起来好长, VFL又不好操作具体约束, 写出来的代码可读性也不是很高.</p>
<h2 id="如何创建一个约束"><a href="#如何创建一个约束" class="headerlink" title="如何创建一个约束"></a>如何创建一个约束</h2><p>苹果在NSLayoutConstraint中提供了一个类方法</p>
<pre><code class="objc hljs">+(instancetype)constraintWithItem:(<span class="hljs-keyword">id</span>)view1 
                        attribute:(<span class="hljs-built_in">NSLayoutAttribute</span>)attr1 
                        relatedBy:(<span class="hljs-built_in">NSLayoutRelation</span>)relation
                           toItem:(<span class="hljs-keyword">id</span>)view2 
                        attribute:(<span class="hljs-built_in">NSLayoutAttribute</span>)attr2 
                       multiplier:(<span class="hljs-built_in">CGFloat</span>)multiplier 
                         constant:(<span class="hljs-built_in">CGFloat</span>)c;</code></pre><p>用于创建两个item之间的约束, 一次只能描述某两个属性的关系. 比如需要view1的left和view2的right保持10的偏移量. 那么这里的调用就是这样:</p>
<pre><code class="objc hljs">[<span class="hljs-built_in">NSLayoutConstraint</span> constraintWithItem:view1 
                             attribute:<span class="hljs-built_in">NSLayoutAttributeLeft</span>
                             relatedBy:<span class="hljs-built_in">NSLayoutRelationEqual</span>
                                toItem:view2
                             attribute:<span class="hljs-built_in">NSLayoutAttributeRight</span>
                            multiplier:<span class="hljs-number">1</span>
                              constant:<span class="hljs-number">10</span>];</code></pre><p>好长有木有, 但是很清晰, 至少明确地表达了两个view的两个属性间的关系. VFL的描写方式就不写了. 这里获取到了一个constraint对象, 下一步我需要让它生效, 我需要找到一个view去调用<code>[view addConstraint:constraint]</code>, 这个view必须是view1和view2的一个公共父view. 完成操作后, 等到下一个刷新周期约束就会生效了.</p>
<h2 id="XLYAutoLayoutEasy"><a href="#XLYAutoLayoutEasy" class="headerlink" title="XLYAutoLayoutEasy"></a>XLYAutoLayoutEasy</h2><p>虽然创建约束的方法很直观, 但是我仍然认为它太复杂, 太长了. 屏幕杀手. 先看一眼我的lib如何描写一个约束.</p>
<pre><code class="objc hljs">  view1.layoutLeft.equalTo(view2.layoutRight).constant(<span class="hljs-number">10</span>);</code></pre><p>怎么看都更加简单. <strong>简化约束的创建是XLYAutoLayoutEasy的核心</strong>, 所有的约束创建都使用类似的方法. 如果firstItem和secondItem使用相同的layout属性, 可以不用书写secondItem的layout属性. 如下:</p>
<pre><code class="objc hljs">  <span class="hljs-comment">//view1的宽度等于view2的宽度乘1再加上10</span>
  view1.layoutWidth.equalTo(view2).constant(<span class="hljs-number">10</span>);</code></pre><p>如果是根superView的对应属性做约束, 甚至可以写成这样:</p>
<pre><code class="objc hljs">  <span class="hljs-comment">//等同view1.layoutLeading.equalTo(superView.layoutLeading).constant(100);</span>
  view1.layoutLeading.equalTo(<span class="hljs-number">100</span>);</code></pre><p>上面的单行代码创建的是XLYConstraint对象, 需要调用resultConstraint来获取NSLayoutConstraint对象.</p>
<p>XLYAutoLayoutEasy还顺带提供了一些helper方法, 辅助激活, 更新和重建约束. </p>
<h4 id="批量创建约束"><a href="#批量创建约束" class="headerlink" title="批量创建约束"></a>批量创建约束</h4><pre><code class="objc hljs">[<span class="hljs-built_in">UIView</span> makeConstraints:^{
  testView.layoutTop.equalTo(<span class="hljs-keyword">self</span>.topLayoutGuideView.layoutBottom).constant(<span class="hljs-number">50</span>);
  testView.layoutTrailing.equalTo(<span class="hljs-keyword">self</span>.view).constant(<span class="hljs-number">-50</span>);
  testView.layoutLeading.equalToConstant(<span class="hljs-number">50</span>);
  testView.layoutHeight.equalToConstant(<span class="hljs-number">100</span>);
}];</code></pre><p>使用makeConstraint的方法会自动将block里面创建的约束激活, 无需再自行寻找公共父view进行添加.</p>
<h4 id="更新约束"><a href="#更新约束" class="headerlink" title="更新约束"></a>更新约束</h4><pre><code class="objc hljs">[<span class="hljs-built_in">UIView</span> updateConstraints:^{
  <span class="hljs-keyword">self</span>.testView.layoutLeading.equalTo(<span class="hljs-keyword">self</span>.view).constant(<span class="hljs-number">100</span>);
  <span class="hljs-keyword">self</span>.testView.layoutHeight.equalTo(<span class="hljs-number">50</span>);
}];</code></pre><p>所有在updateConstraints里面创建的约束会首先查找有没有一个约束和创建出来的约束相似(后文会解释相似的判定), 如果有, 则修改constant, 否则添加新创建的约束. 
如果使用iOS的方法, 则需要记录下之前创建的约束来修改constant. </p>
<h4 id="重建约束"><a href="#重建约束" class="headerlink" title="重建约束"></a>重建约束</h4><pre><code class="objc hljs">[<span class="hljs-built_in">UIView</span> remakeConstraints:^{  <span class="hljs-keyword">self</span>.testView.layoutBottom.equalTo(<span class="hljs-keyword">self</span>.bottomLayoutGuideView.layoutTop).constant(<span class="hljs-number">-100</span>);
    <span class="hljs-keyword">self</span>.testView.layoutWidth.equalTo(<span class="hljs-number">100</span>);
    <span class="hljs-keyword">self</span>.testView.layoutHeight.equalTo(<span class="hljs-number">100</span>);
    <span class="hljs-keyword">self</span>.testView.layoutLeading.equalTo(<span class="hljs-keyword">self</span>.view.layoutLeading);
}];</code></pre><p>方法会记录所有在remakeConstraints中出现的作为firstItem的view, 并把跟这些view相关的所有约束去掉(不包含hugging, compression resistance 的约束), 然后重新激活新创建的约束.</p>
<h2 id="灵感"><a href="#灵感" class="headerlink" title="灵感"></a>灵感</h2><p>大前提是<code>translatesAutoresizingMaskIntoConstraints = NO</code>. 否则无法玩耍了. 既然使用了autoLayout就不要再搭着AutoResizingMask了.</p>
<p>简单描述一下XLYAutoLayoutEasy的设计灵感来源. 在storyboard中编辑一个约束时, 我发现xcode标注了firstItem, relation, secondItem, constant, priority, multiplier. 其中firstItem和secondItem显示的是view.width这样的形式, 整个约束看起来十分清晰. 于是想到如果能在代码里面用</p>
<pre><code class="null hljs">view1<span class="hljs-selector-class">.width</span> equalTo view2<span class="hljs-selector-class">.width</span>, constant <span class="hljs-number">50</span>, priority <span class="hljs-number">1000</span>, multiplier <span class="hljs-number">1</span></code></pre><p>这样的形式描述那多好.一下就看明白了. 于是想到给UIView添加分类, 提供类似width, height, leading这样的property. 为了准确表达是布局的属性, 在前面添加了layout, 于是就成了layoutWidth, layoutHeight, layoutLeading. 没有添加xly_的前缀是为了书写方便.
 首先定义了最基础的API:</p>
<pre><code class="objc hljs">view.layoutWidth.equalTo(view2.layoutWidth);</code></pre><p>关系有等于, 大于等于, 小于等于. constant, priority以及multiplier都有默认值, 分别是0, 1000, 1. 如果需要修改的话, 就在上面的表达式后面继续书写:</p>
<pre><code class="objc hljs">view.layoutWidth.equalTo(view2.layoutWidth).constant(<span class="hljs-number">100</span>).priority(<span class="hljs-number">750</span>).multiplier(<span class="hljs-number">1.5</span>);</code></pre><p>这三个属性书写的顺序可以随意交换.但是一定是在关系之后.</p>
<p>这样的形式更像c或者swift的语法, OC里面怎么做呢? 用block. block在调用时是block()的形式. 只要返回值可以使用<code>.</code> 进行调用的话这样的书写就没有问题. 因此就诞生了如下的方法:</p>
<pre><code class="objc hljs">    - (XLYConstraint *(^)(<span class="hljs-keyword">id</span> attr))equalTo;
    - (XLYConstraint *(^)(<span class="hljs-built_in">CGFloat</span> constant))constant;</code></pre><p>用block作为返回值, 然后用()进行调用, 得到XLYConstraint的对象, 然后重复. 这样就能写出上面所展示的那种代码了. 我觉得这里如果用<code>[]</code> 进行方法调用的话, 可读性会比较差, 所以...</p>
<p><code>view.layoutXXX</code>这样的属性是XLYViewAttribute类型, 调用equalTo等描述关系的方法后才产生XLYConstraint对象, 这样做一方面是为了从概念上区分出约束的item和其他参数, 另一方面也方便了代码的分布.</p>
<p>通过这样的调用最终生成的XLYConstraint对象记录了一个约束所需要的8个参数. 然后调用其<code>resultConstraint</code>方法将生成所对应的NSLayoutConstraint对象.</p>
<h2 id="helper方法"><a href="#helper方法" class="headerlink" title="helper方法"></a>helper方法</h2><p>一个约束被创建后需要激活. ios7及以下系统需要自己寻找公共父view并添加, 因此我需要一个寻找两个view公共父view的方法. ios8及以上系统只需要设置active为YES即可.
在更新约束时, 我需要寻找到和当前约束&#39;类似&#39;的约束. 
在重建约束时, 我需要找到跟一个view相关联的所有约束.</p>
<p>以上就是make, update和remake所依赖的核心方法.</p>
<h4 id="激活约束"><a href="#激活约束" class="headerlink" title="激活约束"></a>激活约束</h4><p>给NSLayoutConstraint添加了一个分类, 提供了xly_install 和 xly_uninstall方法来进行激活和移除操作, 方法中根据系统版本进行区别调用. 如果是ios8及以上只需设置active属性, ios7及以下则需要寻找最低公共父view来进行添加.</p>
<h4 id="更新约束-1"><a href="#更新约束-1" class="headerlink" title="更新约束"></a>更新约束</h4><p>更新约束时, 首先是创建了在block里面书写的约束, 然后去寻找是否有一个相似的约束, 如果没有的话就直接激活约束, 如果有就替换constant的值.</p>
<p>什么是相似? 从NSLayoutConstraint中能看出来, 创建完一个约束后能修改的值只有priority和constant, priority还不建议在约束激活后再修改. 虽然经过测试发现只要优先级不是1000, 并且改动后的值也不是1000就没有问题, 否则崩溃. 这里尊重苹果的文档, 把优先级不同的约束当成不同的约束. 因此,相似的概念就是除了constant以外, 其他的值是<strong>逻辑相等</strong>的. 为什么不是完全相等? 因为约束并不是单向的, 它是一个双向的限制, 约束的公式如下:</p>
<pre><code class="null hljs">view1.attr1 = view2.attr2 * multiplier + <span class="hljs-built_in">constant</span></code></pre><p>这个计算规则等同于下面这一个:</p>
<pre><code class="null hljs">view2.attr2 = view1.attr1 * ( <span class="hljs-number">1</span>/multiplier) - <span class="hljs-built_in">constant</span>/multiplier</code></pre><p>因此, 在寻找相似的约束时必须考虑第二种形式. 我定义相似的结果为3种, 相似, 逆向相似以及不相似. 查找时还得小心一种很特别的约束, 是通过设置view的hugging和compression resistance生成的. 这种约束的类是<code>NSContentSizeLayoutConstraint</code>, 需要过滤掉. 最后一个细节就是相似的约束可能不止一个, 这种情况下多半是代码有问题, 约束加多了, 但是不管怎么着, 我只取最新的一个, 即最后添加的那个, 因此我会倒序遍历constraints数组来进行查找.</p>
<h4 id="重建约束-1"><a href="#重建约束-1" class="headerlink" title="重建约束"></a>重建约束</h4><p>重建, 就得先毁灭再重生. 应该被毁灭的是哪些呢? 我善做主张, 将所有关联的约束全部干掉. 比如代码这么写:</p>
<pre><code class="objc hljs">[<span class="hljs-built_in">UIView</span> remakeConstraints:^{  
  <span class="hljs-keyword">self</span>.testView.layoutBottom.equalTo(<span class="hljs-keyword">self</span>.bottomLayoutGuideView.layoutTop).constant(<span class="hljs-number">-100</span>);
  <span class="hljs-keyword">self</span>.testView.layoutWidth.equalTo(<span class="hljs-number">100</span>);
  <span class="hljs-keyword">self</span>.testView.layoutHeight.equalTo(<span class="hljs-number">100</span>);
  <span class="hljs-keyword">self</span>.testView.layoutLeading.equalTo(<span class="hljs-keyword">self</span>.view.layoutLeading);
  <span class="hljs-comment">//这里不再多写了, view2也进行重建</span>
  <span class="hljs-keyword">self</span>.view2 ...
}];</code></pre><p>block里创建了多个约束, 作为firstItem出现的是testView和view2, 因此所有和testView和view2有关联的约束全部干掉. 约束是双向的, 有关联就是约束的firstItem或者secondItem等于这个view. 在寻找关联的约束时只能从自己开始, 逐步往window遍历所有的约束, 将关联的约束记下. 这里本来想利用runtime去替换addConstant和setActive方法, 在方法中进行记录的, 但是发现了iOS的一些诡异得无法解释的现象, 放弃了这条路, 只能每次遍历查找了, 效率相对低点儿. 这里同样要去掉<code>NSContentSizeLayoutConstraint</code>类型的约束.</p>
<h2 id="兼顾swift"><a href="#兼顾swift" class="headerlink" title="兼顾swift"></a>兼顾swift</h2><p>以上的代码如果bridge到swift使用将显得很funny. 因为方法返回的是一个闭包, OC直接使用()就可以跟在后面继续调用, 但是swift会变成这样:</p>
<pre><code class="swift hljs">  view1.layoutLeft.equalTo()(view2.layoutRight).constant()(<span class="hljs-number">10</span>)</code></pre><p>因此, 我专门为swift添加了两个头文件, 使得swift里面也能跟OC的写法一样.</p>
<pre><code class="objc hljs"><span class="hljs-comment">//其中一个, 另一个见代码</span>
- (XLYConstraint *)equalTo:(<span class="hljs-keyword">id</span>)attr;
- (XLYConstraint *)greaterThanOrEqualTo:(<span class="hljs-keyword">id</span>)attr;
- (XLYConstraint *)lessThanOrEqualTo:(<span class="hljs-keyword">id</span>)attr;</code></pre><p>也专门弄了一个给swift bridge header用的<code>XLYAutoLayoutEasy-swift.h</code>以区分import的头文件.</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>用helper方法配合简化约束的写法, 就能用较短的代码量写出我认为更加清晰可读的布局代码. 更新重建的操作也能更加容易. </p>
<p>写代码, 多思考, 想清楚了需要什么再写. 多画图有助于思考.</p>
<p>另外, 感谢我的她对我的包容和支持.</p>
</div><div class="article-share"><script type="text/javascript" src="/blog/js/share.js?v=0.0.0" async></script><a data-url="" data-id="ciooc9usi000eaapg6zmotyr9" class="article-share-link">分享</a><div class="article-share-box"><div class="article-share-links"><a target="_blank" title="Twitter" class="article-share-twitter"></a><a target="_blank" title="Facebook" class="article-share-facebook"></a><a target="_blank" title="Sina Weibo" class="article-share-sinaweibo"></a><a target="_blank" title="Wechat" class="article-share-wechat"></a></div></div></div><div class="tags"><a href="/blog/tags/iOS/">iOS</a><a href="/blog/tags/Github/">Github</a></div><div class="post-nav"><a href="/blog/2016/03/15/年后小总结/" class="pre">2016 年后小总结</a><a href="/blog/2014/12/08/talk_about_autolayout/" class="next">AutoLayout的小吐槽</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar-placeholder"> </div><div id="sidebar-container"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Google"/><input type="hidden" name="sitesearch"/><script>var input=document.getElementsByName('sitesearch')[0];if(input){input.setAttribute('value', window.location.host);}</script></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/日常/">日常</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/blog/tags/XCode/" style="font-size: 15px;">XCode</a> <a href="/blog/tags/Github/" style="font-size: 15px;">Github</a> <a href="/blog/tags/年终总结/" style="font-size: 15px;">年终总结</a> <a href="/blog/tags/swift/" style="font-size: 15px;">swift</a> <a href="/blog/tags/NativeScript/" style="font-size: 15px;">NativeScript</a> <a href="/blog/tags/JS/" style="font-size: 15px;">JS</a> <a href="/blog/tags/cocoapods/" style="font-size: 15px;">cocoapods</a> <a href="/blog/tags/workspace/" style="font-size: 15px;">workspace</a> <a href="/blog/tags/心情/" style="font-size: 15px;">心情</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/26/break-swift-init-rule/">对swift中单例的init搞破坏</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/20/the-Twenty-of-May/">the Twenty of May</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/05/19/reuse-internal-codes/">复用内部公用代码的几种方式</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/04/17/make-AutoLayout-X/">make AutoLayout X</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/04/13/改用hexo了/">改用hexo了!</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/04/13/swift-AnyObject-little-tips/">swift AnyObject little tips</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/04/11/nativescript/">集成NativeScript iOSRuntime到已有工程</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/03/28/swift_type_convert/">swift 2.2 类型转换小坑</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2016/03/15/年后小总结/">2016 年后小总结</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2014/12/08/XLYAutoLayoutEasy/">XLYAutoLayoutEasy</a></li></ul></div></div><script type="text/javascript" src="/blog/js/sidebar.js?v=0.0.0"></script></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/blog/." rel="nofollow">kaizei.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a> Modified by <a rel="nofollow" target="_blank" href="https://github.com/kaizeiyimi">ME.</a></div></div></div></div></body></html>