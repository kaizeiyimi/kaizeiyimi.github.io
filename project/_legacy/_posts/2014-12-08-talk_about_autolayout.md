---
layout: post
title:  "AutoLayout的小吐槽"
date:   2014-12-08 11:00:00
categories: 技术
tags: [iOS]
---



突然有一天, 苹果还在ios6的时候, 它发布了新的布局方式, 取名叫**AutoLayout**, 听着很高大上--自动布局. 但是我这篇文章除了简单介绍一下它以外更多的是要吐槽的, 其实也就稍微吐一点点它的使用问题.

## AutoResizing -- AutoLayout之前的布局

做app必然涉及到布局, 现在改为自动布局的话, 那么以前的布局是什么, AutoLayout解决了什么问题?

 以前的布局方式我觉得可以叫做半自动布局. 因为AutoResizing是一种spring-strut方式, 仅描述了view在其superView大小变化时自身如何变化. 它可以描述一个view相对于superView的上下左右四个边距是否固定, 自身的宽高是否可以拉伸这么6个属性, 对于大部分的app来讲AutoResizing已经足够描述布局规则了. 
 
 但是如果view的大小不好计算(依赖内容)或者有多个view有相互依赖的关系, AutoResizing就不够用了, 并且布局将变得很繁琐无聊容易出错.
 
 布局的方式大致如下:
 
 - 你可能需要对view调用sizeToFit 或者其他方法来将view的frame调整到一个合适的大小.
 - 也可以在某个父view的layoutSubviews方法中根据需求调整这些view的大小并计算这些view的各种位置. 
 
其中最麻烦的就是字体相关的布局计算, 因为文字渲染后的行高都略大于字号, 没法直接设定label高度, 必须用NSString的一个分类方法计算在一定条件下的渲染大小, 然后才能参与计算.

## AutoLayout 解决的问题

AutoLayout试图解决控件大小变化以及位置变化的问题. 

1. 控件大小的问题: 比如label控件默认情况下会有比较低的优先级阻止自身变大, 相对较高的优先级阻止自身被压缩, 在不引起变大或者压缩的情况下, label会保持和内容一样大. 你仍然可以固定它的大小, 但是不建议. 当你改变了text, label自动就会调整大小, 不需要你再去为了label的宽高抓狂了. 当然, 有的场景仍然需要手动计算文字渲染后大小.  另外一种大小问题是相对计算的, 比如一个view的大小或者位置会影响到另一个view的大小, 当这个view变化时另一个的大小也会相应变化.

2.  控件位置问题: AutoLayout最直接的表现就是能够定义两个控件之间的相对位置. 比如view1相对view2保持10的间距, 那么当view1的origin改变时, view2的origin也会随之变化.

显然用AutoLayout进行布局看起来是很好的, 事实上也是很好的, 尽管不是那么完美. storyboard和AutoLayout可以帮助开发者将绝大部分的UI逻辑和业务逻辑分离开, 并且修改和维护的复杂性也还能接受, 习惯了的话也是能很较快速地调整约束的.

AutoLayout中一次只能描述一个view的宽高或者描述两个view之间的关系. 能描述的属性很多, 但是不是随便用的, 比如不能描述一个view的宽和另一个view的leading相等, iOS直接崩溃并告诉你这两个属性不能配对. 当你描述好了一个约束后, 你需要将其激活, 怎么激活? UIView有一个addConstraint的方法, 需要你自己添加. 那么该让谁来add呢? 经过一些测试发现, 这个调用add的view必须是约束中两个view的公共父view, 不一定是最低的那个, 只要是公共父view即可. 但是建议添加在最低公共父view中. 如果不想要一个约束了怎么办? UIView也有removeConstraint的方法, 去掉你不想要的即可.


## 开始吐槽

然后我要开始吐槽了. 

1. 激活的问题.
	这算什么? 我自己去找公共父view? kidding me? 这个过程明显可以自动搞定啊. 然后发现iOS8支持了新的API. NSLayoutConstraint中多了一个active属性, 设置为YES即激活, NO即干掉. 但是对于iOS7及以下系统仍然需要自己找view去add和remove.

2. NSLayoutConstraint类方法创建约束
NSLayoutConstraint有一个类方法用于创建一个约束, 这个方法有7个参数. 这7个参数不包含priority, 如果要设置要优先级还需要在创建约束后修改. 这个方法写起来简直就是屏幕杀手, 如果要规范一点一个参数一行,那么就是7行, 多写几个就轻松过一屏. 如果不折行, 那堆在一起的代码简直让人受不了. 那真是一坨一坨的.

3. VFL
也许苹果也觉得用一个带7个参数的方法去创建1个约束的方式有点儿不那么美观和方便, 于是开发了Visual Format Language, 目的是为了帮助开发者快速创建约束. 但是问题是, 这真的有效么? 使用VFL能一次性在一个方向上创建多个约束, 然后返回一个数组. 但是, 如果我需要根据需求调整其中一个约束呢? 我怎么获取到我想要的那个约束? 很遗憾, 你必须把VFL拆散, 对于你要的那一个约束, 要么你用NSLayoutConstraint的类方法去创建, 要么你用VFL去描述你要的那一个约束, 然后数组里面应该就只有那一个你要的约束了.
另外一点, 用VFL要注意的就是metrics和views两个字典, 一个是记录format里面的各种标量, 另一个记录出现在format里面的view, 也挺麻烦的.

4. 动画
貌似苹果还没有想好怎么比较方便地将约束和动画结合起来. 每次想动画呈现约束的变化, 都需要先改constant, 然后单独写一个动画, 在block里面找到一个view调用layoutIfNeeded. ╮(╯▽╰)╭, 为什么就不能稍微方便一点, 在animation的block里面修改约束就自动动画搞起呢? 技术上完全可行的说, 因为修改frame, alpha这些参数都是OK的.

吐槽的基本上都是代码中编写AutoLayout相关代码的部分, 实际项目中也确实有不少需求是需要比较动态的布局的. 如果app比较简单, 使用storyboard就能完成布局描述的话就最好了, 那样将省掉非常多的编辑和调试约束的时间, 并且以后的维护也相对方便.

## 总结

AutoLayout整体很强大, 而且在iOS环境中很有必要. 现在已经有多种尺寸的设备了, 使用AutoLayout会大大减少开发者适配的工作, 是时候了骚年.

另外, 本人开发了一个用于简化代码编写AutoLayout约束的小库 [XLYAutoLayoutEasy](https://github.com/kaizeiyimi/XLYAutoLayoutEasy), 个人感觉更具有可读性和可维护性, 还支持swift哦.
